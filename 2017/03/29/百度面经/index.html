<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>百度面经 | 明动天下</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="2017/03/29  下午参加了百度云计算部门的面试
1.Elasticsearch 的系统架构及选主机制
各部分功能（待续）   多个节点运行elasticsearch服务可以组成一个集群，在这个集群里面有一个主节点(master),elasticsearch是去中心化的，所以这里的主节点是动态选举出来的，不存在单点故障。
   在同一个子网内，只需要在每个节点上设置相同的集群名,elasti">
<meta property="og:type" content="article">
<meta property="og:title" content="百度面经">
<meta property="og:url" content="http://yoursite.com/2017/03/29/百度面经/index.html">
<meta property="og:site_name" content="明动天下">
<meta property="og:description" content="2017/03/29  下午参加了百度云计算部门的面试
1.Elasticsearch 的系统架构及选主机制
各部分功能（待续）   多个节点运行elasticsearch服务可以组成一个集群，在这个集群里面有一个主节点(master),elasticsearch是去中心化的，所以这里的主节点是动态选举出来的，不存在单点故障。
   在同一个子网内，只需要在每个节点上设置相同的集群名,elasti">
<meta property="og:image" content="http://yoursite.com/img/elasticsearch架构图.png">
<meta property="og:image" content="http://yoursite.com/img/浅拷贝1.png">
<meta property="og:image" content="http://yoursite.com/img/深拷贝1.png">
<meta property="og:updated_time" content="2017-04-06T06:53:52.005Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="百度面经">
<meta name="twitter:description" content="2017/03/29  下午参加了百度云计算部门的面试
1.Elasticsearch 的系统架构及选主机制
各部分功能（待续）   多个节点运行elasticsearch服务可以组成一个集群，在这个集群里面有一个主节点(master),elasticsearch是去中心化的，所以这里的主节点是动态选举出来的，不存在单点故障。
   在同一个子网内，只需要在每个节点上设置相同的集群名,elasti">
<meta name="twitter:image" content="http://yoursite.com/img/elasticsearch架构图.png">
  
    <link rel="alternative" href="/atom.xml" title="明动天下" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/me.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">明动天下</a></h1>
		</hgroup>

		
		<p class="header-subtitle">提笔写诗   落笔代码</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">概览</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/wmingstar" title="github">github</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/wmingstar" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/spark/" style="font-size: 15px;">spark</a> <a href="/tags/剑指Offer/" style="font-size: 10px;">剑指Offer</a> <a href="/tags/操作系统/" style="font-size: 15px;">操作系统</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/笔试/" style="font-size: 10px;">笔试</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">明动天下</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/img/me.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">明动天下</h1>
			</hgroup>
			
			<p class="header-subtitle">提笔写诗   落笔代码</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">概览</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/wmingstar" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/wmingstar" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-百度面经" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/29/百度面经/" class="article-date">
  	<time datetime="2017-03-29T12:27:39.000Z" itemprop="datePublished">2017-03-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      百度面经
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>2017/03/29  下午参加了百度云计算部门的面试</p>
<h3 id="1-Elasticsearch-的系统架构及选主机制"><a href="#1-Elasticsearch-的系统架构及选主机制" class="headerlink" title="1.Elasticsearch 的系统架构及选主机制"></a>1.Elasticsearch 的系统架构及选主机制</h3><p><img src="/img/elasticsearch架构图.png" alt=""></p>
<h4 id="各部分功能（待续）"><a href="#各部分功能（待续）" class="headerlink" title="各部分功能（待续）"></a>各部分功能（待续）</h4><p>   多个节点运行elasticsearch服务可以组成一个集群，在这个集群里面有一个主节点(master),<br>elasticsearch是去中心化的，所以这里的主节点是动态选举出来的，不存在单点故障。</p>
<p>   在同一个子网内，只需要在每个节点上设置相同的集群名,elasticsearch就会自动的把这些集群名相同<br>的节点组成一个集群。节点和节点之间通讯以及节点之间的数据分配和平衡全部由elasticsearch自动管理。</p>
<p>   每一个运行实例称为一个节点,每一个运行实例既可以在同一机器上,也可以在不同的机器上。<br>所谓运行实例,就是一个ES服务器进程，在测试环境中可以在一台服务器上运行多个服务器进程，在生产环境中<br>建议每台服务器运行一个服务器进程。</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>Elasticsearch 看名字就能大概了解下它是一个弹性的搜索引擎。首先弹性隐含的意思是分布式，<br>单机系统是没法弹起来的，然后加上灵活的伸缩机制，就是这里的 Elastic 包含的意思。<br>它的搜索存储功能主要是 Lucene 提供的，Lucene 相当于其存储引擎，<br>它在之上封装了索引，查询，以及分布式相关的接口。</p>
<p>集群（Cluster）：一组拥有共同的 cluster name 的节点。</p>
<p>节点（Node) ：集群中的一个 Elasticearch 实例。</p>
<p>索引（Index)： 相当于关系数据库中的database概念，一个集群中可以包含多个索引。这个是个逻辑概念。</p>
<p>主分片（Primary shard）： 索引的子集，索引可以切分成多个分片，分布到不同的集群节点上。分片对应的是 Lucene 中的索引。</p>
<p>副本分片（Replica shard）：每个主分片可以有一个或者多个副本。</p>
<p>类型（Type）：相当于数据库中的table概念，mapping是针对 Type 的，同一个索引里可以包含多个 Type。</p>
<p>文档（Document)： 相当于数据库中的row。</p>
<p>字段（Field）：相当于数据库中的column。</p>
<h4 id="服务发现以及选主-ZenDiscovery"><a href="#服务发现以及选主-ZenDiscovery" class="headerlink" title="服务发现以及选主 ZenDiscovery"></a>服务发现以及选主 ZenDiscovery</h4><p>   分布式系统要解决的第一个问题就是节点之间互相发现以及选主的机制。如果使用了 Zookeeper/Etcd<br>这样的成熟的服务发现工具，这两个问题都一并解决了。<br>但 Elasticsearch 并没有依赖这样的工具，带来的好处是部署服务的成本和复杂度降低了，<br>不用预先依赖一个服务发现的集群，缺点当然是将复杂度带入了 Elasticsearch 内部。</p>
<p>1.节点启动后先ping（这里的ping是 Elasticsearch 的一个RPC命令。如果<br>discovery.zen.ping.unicast.hosts 有设置，则ping设置中的host，否则尝试ping localhost 的几个端口，<br>Elasticsearch 支持同一个主机启动多个节点）</p>
<p>2.Ping的response会包含该节点的基本信息以及该节点认为的master节点。</p>
<p>3.选举开始，先从各节点认为的master中选，规则很简单，按照id的字典序排序，取第一个。</p>
<p>4.如果各节点都没有认为的master，则从所有节点中选择，规则同上。这里有个限制条件就是<br>discovery.zen.minimum_master_nodes，如果节点数达不到最小值的限制，则循环上述过程，直到节点数足够<br>可以开始选举。</p>
<p>5.最后选举结果是肯定能选举出一个master，如果只有一个local节点那就选出的是自己。</p>
<p>6.如果当前节点是master，则开始等待节点数达到 minimum_master_nodes，然后提供服务。</p>
<p>7.如果当前节点不是master，则尝试加入master。</p>
<p>Elasticsearch 将以上服务发现以及选主的流程叫做 ZenDiscovery 。<br>由于它支持任意数目的集群（1-N）,所以不能像 Zookeeper/Etcd 那样限制节点必须是奇数，<br>也就无法用投票的机制来选主。<br>而是通过一个规则，只要所有的节点都遵循同样的规则，得到的信息都是对等的，选出来的主节点肯定是一致<br>的。但分布式系统的问题就出在信息不对等的情况，这时候很容易出现脑裂（Split-Brain）的问题，大多数解<br>决方案就是设置一个quorum值，要求可用节点必须大于quorum（一般是超过半数节点），才能对外提供服务。<br>而 Elasticsearch 中，这个quorum的配置就是 discovery.zen.minimum_master_nodes 。 说到这里要吐槽下Elasticsearch 的方法和变量命名，它的方法和配置中的master指的是master的候选节点，也就是说可能成为master的节点，并不是表示当前的master。</p>
<h3 id="2-判断一个单向链表是否有环，若是循环链表，找出链表入口-加以证明"><a href="#2-判断一个单向链表是否有环，若是循环链表，找出链表入口-加以证明" class="headerlink" title="2.判断一个单向链表是否有环，若是循环链表，找出链表入口;加以证明"></a>2.判断一个单向链表是否有环，若是循环链表，找出链表入口;加以证明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static Node findEntryNode(Node head)&#123;</span><br><span class="line">        if(head==null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Node slow = head;</span><br><span class="line">        Node quick = head;</span><br><span class="line">        boolean flag = false;</span><br><span class="line">        while (quick.next.next!=null)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            quick = quick.next.next;</span><br><span class="line">            if(slow == quick)&#123;</span><br><span class="line">                flag = true;</span><br><span class="line">                System.out.println(&quot;有环&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!flag)&#123;</span><br><span class="line">            System.out.println(&quot;无环&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = head;</span><br><span class="line">        while (slow!=quick)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            quick=quick.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test01();</span><br><span class="line">        test02();</span><br><span class="line">        test03();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6</span><br><span class="line">    private static void test01() &#123;</span><br><span class="line">        Node n1 = new Node(1);</span><br><span class="line">        Node n2 = new Node(2);</span><br><span class="line">        Node n3 = new Node(3);</span><br><span class="line">        Node n4 = new Node(4);</span><br><span class="line">        Node n5 = new Node(5);</span><br><span class="line">        Node n6 = new Node(6);</span><br><span class="line"></span><br><span class="line">        n1.next = n2;</span><br><span class="line">        n2.next = n3;</span><br><span class="line">        n3.next = n4;</span><br><span class="line">        n4.next = n5;</span><br><span class="line">        n5.next = n6;</span><br><span class="line">        Node result = findEntryNode(n1);</span><br><span class="line">        if (result != null) &#123;</span><br><span class="line">            System.out.println(result.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6</span><br><span class="line">    //       ^        |</span><br><span class="line">    //       |        |</span><br><span class="line">    //       +--------+</span><br><span class="line">    private static void test02() &#123;</span><br><span class="line">        Node n1 = new Node(1);</span><br><span class="line">        Node n2 = new Node(2);</span><br><span class="line">        Node n3 = new Node(3);</span><br><span class="line">        Node n4 = new Node(4);</span><br><span class="line">        Node n5 = new Node(5);</span><br><span class="line">        Node n6 = new Node(6);</span><br><span class="line"></span><br><span class="line">        n1.next = n2;</span><br><span class="line">        n2.next = n3;</span><br><span class="line">        n3.next = n4;</span><br><span class="line">        n4.next = n5;</span><br><span class="line">        n5.next = n6;</span><br><span class="line">        n6.next = n3;</span><br><span class="line">        Node result = findEntryNode(n1);</span><br><span class="line">        if (result != null) &#123;</span><br><span class="line">            System.out.println(result.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 &lt;-+</span><br><span class="line">    //                |   |</span><br><span class="line">    //                +---+</span><br><span class="line">    private static void test03() &#123;</span><br><span class="line">        Node n1 = new Node(1);</span><br><span class="line">        Node n2 = new Node(2);</span><br><span class="line">        Node n3 = new Node(3);</span><br><span class="line">        Node n4 = new Node(4);</span><br><span class="line">        Node n5 = new Node(5);</span><br><span class="line">        Node n6 = new Node(6);</span><br><span class="line"></span><br><span class="line">        n1.next = n2;</span><br><span class="line">        n2.next = n3;</span><br><span class="line">        n3.next = n4;</span><br><span class="line">        n4.next = n5;</span><br><span class="line">        n5.next = n6;</span><br><span class="line">        n6.next = n6;</span><br><span class="line"></span><br><span class="line">        Node result = findEntryNode(n1);</span><br><span class="line">        if (result != null) &#123;</span><br><span class="line">            System.out.println(result.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h3><p>当快慢指针（slow、fast）相遇时，slow指针肯定没有遍历完链表，而fast指针已经在环内循环了<br>n（n&gt;=1）圈。假设slow指针走了 s 步，则fast指针走了 2s 步。同时，fast指针的步数还等于 s<br>加上在环上多转的 n 圈，设环长为 r，则满足如下关系表达式： </p>
<p>2s = s + nr; 所以可知：s = nr; </p>
<p>假设链表的头节点到“环的尾节点“的长度为L（注意，L不一定是链表长度），环的入口节点与相遇点的<br>距离为 b ，链表的头节点到环入口的距离为a，则满足如下关系表达式：<br>          a + b = s = nr;<br>可得：    a + b = (n - 1)r + r = (n - 1)r + (L - a)<br>进一步得：a = (n - 1)r + (L -a - b)<br>结论： </p>
<p><1> (L - a -b)为相遇点到环入口节点的距离，即从相遇点开始向前移动<br> (L -a -b)步后，会再次到达环入口节点;</1></p>
<p><2> 从链表的头节点到环入口节点的距离 ＝ (n - 1) * 环内循环 ＋ 相遇点到环入口点的距离; </2></p>
<p><3> 于是从链表头与相遇点分别设一个指针，每次各走一步，两个指针必定相遇，且相遇第一点为环入口点。</3></p>
<h3 id="3-线程与进程的区别"><a href="#3-线程与进程的区别" class="headerlink" title="3.线程与进程的区别"></a>3.线程与进程的区别</h3><h4 id="线程与进程的概念"><a href="#线程与进程的概念" class="headerlink" title="线程与进程的概念"></a>线程与进程的概念</h4><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和<br>调度的一个独立单位。</p>
<p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。</p>
<p>线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它<br>可与同属一个进程的其他的线程共享进程所拥有的全部资源.</p>
<p>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</p>
<p>相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的<br>栈空间，拥有独立的执行序列。</p>
<p>在串行程序基础上引入线程和进程是为了提高程序的并发度，从而提高程序运行效率和响应时间。</p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。<br>进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响；<br>而线程只是一个进程中的不同执行路径。</p>
<p>线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，<br>所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</p>
<p>但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>
<p>1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程；<br>2) 线程的划分尺度小于进程，使得多线程程序的并发性高；<br>3) 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率；<br>4) 线程在执行过程中与进程还是有区别的，每个独立的线程有一个程序运行的入口、顺序执行序列和<br>程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。<br>但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。</p>
<h3 id="多进程与多线程"><a href="#多进程与多线程" class="headerlink" title="多进程与多线程"></a>多进程与多线程</h3><p>进程就是一个程序运行的时候被CPU抽象出来的，一个程序运行后被抽象为一个进程；线程是从一个进程里<br>面分割出来的，由于CPU处理进程的时候是采用时间片轮转的方式，所以要把一个大个进程给分割成多个线程，<br>例如：下载文件时，共100个文件，用 10个线程， 文件就被分成了10份来同时下载 1-10 占一个线程 11<br>-20占一个线程,依次类推,线程越多,文件就被分的越多,同时下载 当然速度也就越快。</p>
<p>进程是程序在计算机上的一次执行活动，当你运行一个程序，你就启动了一个进程。</p>
<p>程序只是一组指令的有序集合，它本身没有任何运行的含义，只是一个静态实体。<br>而进程则不同，它是程序在某个数据集上的执行，是一个动态实体。它因创建而产生，因调度而运行，因等待资源或事件而被处于等待状态，因完成任务而被撤消，反映了一个程序在一定的数据集上运行的动态过程。</p>
<p>进程是操作系统分配资源的独立单位。在Windows下，进程又被细化为线程，也就是一个进程下有多个能独立运行的更小的单位。线程(Thread)是进程的一个实体，是CPU调度和分派的基本单位。线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
<p>线程和进程的关系是：线程是属于进程的，线程运行在进程空间内，同一进程所产生的线程共享同一内存空间，当进程退出时该进程所产生的线程都会被强制退出并清除。<br>线程可与属于同一进程的其它线程共享进程所拥有的全部资源，但是其本身基本上不拥有系统资源，只拥有一点在运行中必不可少的信息(如程序计数器、一组寄存器和栈)。</p>
<p>在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，这便是多任务。现代的<br>操作系统几乎都是多任务操作系统，能够同时管理多个进程的运行。</p>
<p>多任务带来的好处是明显的，比如你可以边听mp3边上网，与此同时甚至可以将下载的文档打印出来，而这些任<br>务之间丝毫不会相互干扰。那么这里就涉及到并行的问题，俗话说，一心不能二用，这对计算机也一样，原则<br>上一个CPU只能分配给一个进程，以便运行这个进程。</p>
<p>实现并发技术相当复杂，最容易理解的是“时间片轮转进程调度算法”，它的思想简单介绍如下：在操作系统的<br>管理下，所有正在运行的进程轮流使用CPU，每个进程允许占用CPU的时间非常短(比如10毫秒)，这样用户根本<br>感觉不出来CPU是在轮流为多个进程服务，就好象所有的进程都在不间断地运行一样，但实际上在任何一个时间<br>内有且仅有一个进程占有CPU。</p>
<p>如果一台计算机有多个CPU，如果进程数小于CPU数，则不同的进程可以分配给不同的CPU来运行，这样，多个进<br>程就是真正同时运行的，这便是并行。但如果进程数大于CPU数，则仍然需要使用并发技术。</p>
<p>在Windows中，进行CPU分配是以线程为单位的，一个进程可能由多个线程组成，这时情况更加复杂，但简单地说，有如下关系：<br>总线程数&lt;= CPU数量：并行运行<br>总线程数&gt; CPU数量：并发运行<br>并行运行的效率显然高于并发运行，所以在多CPU的计算机中，多任务的效率比较高。但是，如果在多CPU计算<br>机中只运行一个进程(线程)，就不能发挥多CPU的优势。</p>
<p>多任务操作系统(如Windows)的基本原理是:操作系统将CPU的时间片分配给多个线程,每个线程在操作系统指定<br>的时间片内完成(注意,这里的多个线程是分属于不同进程的)。<br>操作系统不断的从一个线程的执行切换到另一个线程的执行,<br>如此往复,宏观上看来,就好像是多个线程在一起执行。由于这多个线程分属于不同的进程,因此在我<br>们看来,就好像是多个进程在同时执行,这样就实现了多任务。</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>多进程、单线程，多数UNIX(及类UNIX的Linux)是这种操作系统；<br>多进程、多线程，Win32(Windows NT/2000/XP等)、Solaris 2.x和OS/2都是这种操作系统；</p>
<h3 id="死锁的产生、预防和避免"><a href="#死锁的产生、预防和避免" class="headerlink" title="死锁的产生、预防和避免"></a>死锁的产生、预防和避免</h3><p>死锁是由于并发进程只能按互斥方式访问临界资源等多种因素引起的，并且是一种与执行时间和速度密切相关<br>的错误现象。</p>
<p>死锁的一般定义：若在一个进程集合中，每一个进程都在等待一个永远不会发生的事件而形成一个永久的阻塞<br>状态，这种阻塞状态就是死锁。</p>
<p>线程A需要资源X，而线程B需要资源Y，而双方都掌握有对方所要的资源，这种情况称为死锁（deadlock）</p>
<h4 id="死锁的产生条件："><a href="#死锁的产生条件：" class="headerlink" title="死锁的产生条件："></a>死锁的产生条件：</h4><p>1.互斥：系统存在这样一种资源，它在某个时刻只能被分配给一个执行者（也称为线程）使用；<br>2.占有并等待：当请求的资源已被占用从而导致执行者阻塞时，资源占用者不但无需释放该资源，<br>              而且还可以继续请求更多资源；<br>3.不可剥夺(no preemption)：已经分配的资源在其宿主没有释放之前不允许被剥夺；<br>4.循环等待(circular waiting)：系统中存在多个（大于2个）进程形成的封闭的进程链，<br>                             链中的每个进程都在等待它的下一个进程所占有的资源；</p>
<h4 id="死锁的预防："><a href="#死锁的预防：" class="headerlink" title="死锁的预防："></a>死锁的预防：</h4><p>因为独占资源必须以互斥方式进行访问，所以要预防死锁只能从破坏后三个条件下手了。<br>1.破坏 占有并等待 条件：</p>
<p>要破坏这个条件，就要求每个进程必须一次性的请求它们所需要的所有资源，若无法全部获取就等待，直到满<br>足为止，也可以采用事务机制，确保可以回滚，即把获取、释放资源做成原子性的。这个方法实现起来可能会<br>比较困难，因为某些情况下，进程并不能事先知道自己需要哪些资源，也有时候并不需要分配到所有资源就可以运行。</p>
<p>2.破坏 不可剥夺 条件：<br>一个已占有资源的进程若要再申请新的资源，它必须先释放已占有的资源；若随后再需要这些资源，需要重新<br>申请。</p>
<p>3.破坏循环等待条件：<br>将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作。 </p>
<h4 id="死锁的避免："><a href="#死锁的避免：" class="headerlink" title="死锁的避免："></a>死锁的避免：</h4><p>死锁的预防是通过破坏产生条件来阻止死锁的产生，但这种方法破坏了系统的并行性和并发性。</p>
<p>死锁产生的前三个条件是死锁产生的必要条件，也就是说要产生死锁必须具备的条件，而不是存在这3个条件就一定产生死锁，那么只要在逻辑上回避了第四个条件就可以避免死锁。</p>
<p>避免死锁采用的是允许前三个条件存在，但通过合理的资源分配算法来确保永远不会形成环形等待的封闭进程<br>链，从而避免死锁。<br>该方法支持多个进程的并发执行，为了避免死锁，系统动态的确定是否分配一个资源给请求的进程。<br>方法如下：<br>1.如果一个进程的当前请求的资源会导致死锁，系统拒绝启动该进程；<br>2.如果一个资源的分配会导致下一步的死锁，系统就拒绝本次的分配；<br> 显然要避免死锁，必须事先知道系统拥有的资源数量及其属性。</p>
<h3 id="spark内存溢出问题如何解决"><a href="#spark内存溢出问题如何解决" class="headerlink" title="spark内存溢出问题如何解决"></a>spark内存溢出问题如何解决</h3><h3 id="深拷贝-与-浅拷贝的区别-（java）"><a href="#深拷贝-与-浅拷贝的区别-（java）" class="headerlink" title="深拷贝 与 浅拷贝的区别 （java）"></a>深拷贝 与 浅拷贝的区别 （java）</h3><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>对象拷贝(Object Copy)就是将一个对象的属性拷贝到另一个相同类类型的对象中去。在程序中拷贝对象<br>是很常见的，主要是为了在新的上下文环境中复用对象的部分或全部数据。<br>Java中有三种类型的对象拷贝：浅拷贝(Shallow Copy)、深拷贝(Deep Copy)、延迟拷贝(Lazy Copy)。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>浅拷贝：使用一个已知实例对新创建实例的成员变量逐个赋值，这个方式被称为浅拷贝。</p>
<p>深拷贝：当一个类的拷贝构造方法，不仅要复制对象的所有非引用成员变量值，还要为引用类型的成员变量创<br>建新的实例，并且初始化为形式参数实例值。这个方式称为深拷贝。</p>
<p>也就是说浅拷贝只复制一个对象，传递引用，不能复制实例。<br>而深拷贝对对象内部的引用均复制，它是创建一个新的实例，并且复制实例。</p>
<p>对于浅拷贝当对象的成员变量是基本数据类型时，两个对象的成员变量已有存储空间，赋值运算传递值，所以<br>浅拷贝能够复制实例。但是当对象的成员变量是引用数据类型时，就不能实现对象的复制了。</p>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。<br>如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，<br>因此如果其中一个对象改变了这个地址，就会影响到另一个对象。<br><img src="/img/浅拷贝1.png" alt=""><br>在上图中，SourceObject有一个int类型的属性 “field1”和一个引用类型属性”refObj”（引用ContainedObject类型的对象）。<br>当对SourceObject做浅拷贝时，创建了CopiedObject，它有一个包含”field1”拷贝值的属性”field2”以及仍指向refObj本身<br>的引用。由于”field1”是基本类型，所以只是将它的值拷贝给”field2”，但是由于”refObj”是一个引用类型,<br>所以CopiedObject指向”refObj”相同的地址。因此对SourceObject中的”refObj”所做的任何改变都会影响到CopiedObject。</p>
<h4 id="浅拷贝的实现"><a href="#浅拷贝的实现" class="headerlink" title="浅拷贝的实现"></a>浅拷贝的实现</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Subject &#123;</span><br><span class="line"> </span><br><span class="line">   private String name; </span><br><span class="line"></span><br><span class="line">   public Subject(String s) &#123; </span><br><span class="line">      name = s; </span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   public String <span class="function"><span class="title">getName</span></span>() &#123; </span><br><span class="line">      <span class="built_in">return</span> name; </span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   public void <span class="built_in">set</span>Name(String s) &#123; </span><br><span class="line">      name = s; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Student implements Cloneable &#123; </span><br><span class="line"> </span><br><span class="line">   // 对象引用 </span><br><span class="line">   private Subject subj; </span><br><span class="line"> </span><br><span class="line">   private String name; </span><br><span class="line"> </span><br><span class="line">   public Student(String s, String sub) &#123; </span><br><span class="line">      name = s; </span><br><span class="line">      subj = new Subject(sub); </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   public Subject <span class="function"><span class="title">getSubj</span></span>() &#123; </span><br><span class="line">      <span class="built_in">return</span> subj; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   public String <span class="function"><span class="title">getName</span></span>() &#123; </span><br><span class="line">      <span class="built_in">return</span> name; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   public void <span class="built_in">set</span>Name(String s) &#123; </span><br><span class="line">      name = s; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   /** </span><br><span class="line">    *  重写<span class="built_in">clone</span>()方法 </span><br><span class="line">    * @<span class="built_in">return</span> </span><br><span class="line">    */ </span><br><span class="line">   public Object <span class="function"><span class="title">clone</span></span>() &#123; </span><br><span class="line">      //浅拷贝 </span><br><span class="line">      try &#123; </span><br><span class="line">         // 直接调用父类的<span class="built_in">clone</span>()方法</span><br><span class="line">         <span class="built_in">return</span> super.clone(); </span><br><span class="line">      &#125; catch (CloneNotSupportedException e) &#123; </span><br><span class="line">         <span class="built_in">return</span> null; </span><br><span class="line">      &#125; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class CopyTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 原始对象</span><br><span class="line">        Student stud = new Student(<span class="string">"John"</span>, <span class="string">"Algebra"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Original Object: "</span> + stud.getName() + <span class="string">" - "</span> + stud.getSubj().getName());</span><br><span class="line"></span><br><span class="line">        // 拷贝对象</span><br><span class="line">        Student clonedStud = (Student) stud.clone();</span><br><span class="line">        System.out.println(<span class="string">"Cloned Object: "</span> + clonedStud.getName() + <span class="string">" - "</span> + clonedStud.getSubj().getName());</span><br><span class="line"></span><br><span class="line">        // 原始对象和拷贝对象是否一样：</span><br><span class="line">        System.out.println(<span class="string">"Is Original Object the same with Cloned Object: "</span> + (stud == clonedStud));</span><br><span class="line">        // 原始对象和拷贝对象的name属性是否一样</span><br><span class="line">        System.out.println(<span class="string">"Is Original Object's field name the same with Cloned Object: "</span> + (stud.getName() == clonedStud.getName()));</span><br><span class="line">        // 原始对象和拷贝对象的subj属性是否一样</span><br><span class="line">        System.out.println(<span class="string">"Is Original Object's field subj the same with Cloned Object: "</span> + (stud.getSubj() == clonedStud.getSubj()));</span><br><span class="line"></span><br><span class="line">        stud.setName(<span class="string">"Dan"</span>);</span><br><span class="line">        stud.getSubj().setName(<span class="string">"Physics"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Original Object after it is updated: "</span> + stud.getName() + <span class="string">" - "</span> + stud.getSubj().getName());</span><br><span class="line">        System.out.println(<span class="string">"Cloned Object after updating original object: "</span> + clonedStud.getName() + <span class="string">" - "</span> + clonedStud.getSubj().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果输出"><a href="#结果输出" class="headerlink" title="结果输出"></a>结果输出</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Original Object: John - Algebra</span><br><span class="line">Cloned Object: John - Algebra</span><br><span class="line">Is Original Object the same with Cloned Object: <span class="literal">false</span></span><br><span class="line">Is Original Object<span class="string">'s field name the same with Cloned Object: true</span><br><span class="line">Is Original Object'</span>s field subj the same with Cloned Object: <span class="literal">true</span></span><br><span class="line">Original Object after it is updated: Dan - Physics</span><br><span class="line">Cloned Object after updating original object: John - Physics</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我让要拷贝的类Student实现了Clonable接口并重写Object类的clone()方法，然后在方法内部调用super.clone()<br>方法。从输出结果中我们可以看到，对原始对象stud的”name”属性所做的改变并没有影响到拷贝对象clonedStud，但是对引用对象<br>subj的”name”属性所做的改变影响到了拷贝对象clonedStud。</p>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅<br>拷贝速度较慢并且花销较大。<br><img src="/img/深拷贝1.png" alt=""><br>在上图中，SourceObject有一个int类型的属性 “field1”和一个引用类型属性”refObj1”（引用ContainedObject类型的对象）<br>。当对SourceObject做深拷贝时，创建了CopiedObject，它有一个包含”field1”拷贝值的属性”field2”以及包含”refObj1”拷贝值的<br>引用类型属性”refObj2” 。因此对SourceObject中的”refObj”所做的任何改变都不会影响到CopiedObject。</p>
<p>下面是实现深拷贝的一个例子。只是在浅拷贝的例子上做了一点小改动，Subject 和CopyTest 类都没有变化。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Student implements Cloneable &#123; </span><br><span class="line">   // 对象引用 </span><br><span class="line">   private Subject subj; </span><br><span class="line"> </span><br><span class="line">   private String name; </span><br><span class="line"> </span><br><span class="line">   public Student(String s, String sub) &#123; </span><br><span class="line">      name = s; </span><br><span class="line">      subj = new Subject(sub); </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   public Subject <span class="function"><span class="title">getSubj</span></span>() &#123; </span><br><span class="line">      <span class="built_in">return</span> subj; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   public String <span class="function"><span class="title">getName</span></span>() &#123; </span><br><span class="line">      <span class="built_in">return</span> name; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   public void <span class="built_in">set</span>Name(String s) &#123; </span><br><span class="line">      name = s; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   /** </span><br><span class="line">    * 重写<span class="built_in">clone</span>()方法 </span><br><span class="line">    * </span><br><span class="line">    * @<span class="built_in">return</span> </span><br><span class="line">    */ </span><br><span class="line">   public Object <span class="function"><span class="title">clone</span></span>() &#123; </span><br><span class="line">      // 深拷贝，创建拷贝类的一个新对象，这样就和原始对象相互独立</span><br><span class="line">      Student s = new Student(name, subj.getName()); </span><br><span class="line">      <span class="built_in">return</span> s; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果输出-1"><a href="#结果输出-1" class="headerlink" title="结果输出"></a>结果输出</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Original Object: John - Algebra</span><br><span class="line">Cloned Object: John - Algebra</span><br><span class="line">Is Original Object the same with Cloned Object: <span class="literal">false</span></span><br><span class="line">Is Original Object<span class="string">'s field name the same with Cloned Object: true</span><br><span class="line">Is Original Object'</span>s field subj the same with Cloned Object: <span class="literal">false</span></span><br><span class="line">Original Object after it is updated: Dan - Physics</span><br><span class="line">Cloned Object after updating original object: John - Algebra</span><br></pre></td></tr></table></figure>
<p>很容易发现clone()方法中的一点变化。因为它是深拷贝，所以你需要创建拷贝类的一个对象。因为在Student<br>类中有对象引用，所以需要在Student类中实现Cloneable接口并且重写clone方法。</p>
<h3 id="Hashmap与Hashtable的区别"><a href="#Hashmap与Hashtable的区别" class="headerlink" title="Hashmap与Hashtable的区别"></a>Hashmap与Hashtable的区别</h3><p>HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点： </p>
<p>1)HashMap允许键和值是null，而Hashtable不允许键或者值是null。 </p>
<p>2)Hashtable是同步的，而HashMap不是，因此HashMap更适合于单线程环境，而Hashtable适合于多线程环境。 </p>
<p>3）HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator(列举)迭代器不是<br>fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），<br>将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则<br>不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。<br>这条同样也是Enumeration和Iterator的区别。一般认为Hashtable是一个遗留的<br>类。如果你寻求在迭代的时候修改Map，你应该使用CocurrentHashMap</p>
<h3 id="数据库-事务的特性"><a href="#数据库-事务的特性" class="headerlink" title="数据库 事务的特性"></a>数据库 事务的特性</h3><p>事务(Transaction)是并发控制的基本单位。</p>
<p>所谓事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。例如，<br>银行转帐工作：从一个帐号扣款并使另一个帐号增款，这两个操作要么都执行，要么都不执行。</p>
<p>数据库事务必须具备ACID特性：<br>Atomic（原子性）、Consistency（一致性）、Isolation（隔离性）和Durability（持久性）的英文缩写。</p>
<p>原子性：指整个数据库事务是不可分割的工作单位。只有所有的操作执行成功，才算整个事务成功；<br>事务中任何一个SQL语句执行失败，那么已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务<br>前的状态。</p>
<p>　 一致性：指数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。例如对银行转帐事务，不管事务成功还是失败，应该保证事务结束后ACCOUNTS表中Tom和Jack的存款总额为2000元。</p>
<p>　 隔离性：指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。</p>
<p>　 持久性：指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。</p>
<p>事务的（ACID）特性是由关系数据库管理系统（RDBMS，数据库系统）来实现的。数据库管理系统采用日志来保证事务的原子性、一致性和持久性。日志记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据日志，撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。</p>
<p>数据库管理系统采用锁机制来实现事务的隔离性。当多个事务同时更新数据库中相同的数据时，只允许持有锁的事务能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/04/10/offer-4/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          剑指Offer-4
        
      </div>
    </a>
  
  
    <a href="/2017/03/25/TCP协议/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">TCP协议</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="百度面经" data-title="百度面经" data-url="http://yoursite.com/2017/03/29/百度面经/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 明动天下
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>