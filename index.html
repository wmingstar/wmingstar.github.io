<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>明动天下</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="java elasticsearch github">
<meta property="og:type" content="website">
<meta property="og:title" content="明动天下">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="明动天下">
<meta property="og:description" content="java elasticsearch github">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="明动天下">
<meta name="twitter:description" content="java elasticsearch github">
  
    <link rel="alternative" href="/atom.xml" title="明动天下" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/me.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">明动天下</a></h1>
		</hgroup>

		
		<p class="header-subtitle">提笔写诗   落笔代码</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">概览</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/wmingstar" title="github">github</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/wmingstar" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/elasticsearch/" style="font-size: 10px;">elasticsearch</a> <a href="/tags/github/" style="font-size: 11.43px;">github</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/linux/" style="font-size: 17.14px;">linux</a> <a href="/tags/python/" style="font-size: 15.71px;">python</a> <a href="/tags/spark/" style="font-size: 12.86px;">spark</a> <a href="/tags/分布式系统/" style="font-size: 10px;">分布式系统</a> <a href="/tags/操作系统/" style="font-size: 12.86px;">操作系统</a> <a href="/tags/数据库/" style="font-size: 14.29px;">数据库</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/笔试/" style="font-size: 10px;">笔试</a> <a href="/tags/算法/" style="font-size: 18.57px;">算法</a> <a href="/tags/面试/" style="font-size: 12.86px;">面试</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">明动天下</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/img/me.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">明动天下</h1>
			</hgroup>
			
			<p class="header-subtitle">提笔写诗   落笔代码</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">概览</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/wmingstar" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/wmingstar" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-java-单例模式" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/27/java-单例模式/" class="article-date">
  	<time datetime="2017-03-27T11:43:03.000Z" itemprop="datePublished">2017-03-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/27/java-单例模式/">java-单例模式</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访<br>问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>1、单例类只能有一个实例。<br>2、单例类必须自己创建自己的唯一实例。<br>3、单例类必须给所有其他对象提供这一实例。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<h3 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决"></a>主要解决</h3><p>一个全局使用的类频繁地创建与销毁。</p>
<h3 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h3><p>当您想控制实例数目，节省系统资源的时候。</p>
<h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p>
<h3 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h3><p>构造函数是私有的。</p>
<h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p> 1、一个党只能有一个主席。<br> 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作<br> 一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）2、避免对资源的多重占用（比如写文件操作）</p>
<p>###缺点<br>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p> 1、要求生产唯一序列号。<br> 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</p>
<p>注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 SingleObject 类</span></span><br><span class="line">public class SingleObject&#123;</span><br><span class="line">   <span class="comment">#创建一个SingleObject 对象</span></span><br><span class="line">   private static SingleObject instance = new SingleObject();</span><br><span class="line">   </span><br><span class="line">   private <span class="function"><span class="title">SingleObject</span></span>()&#123;&#125;</span><br><span class="line">   </span><br><span class="line">   public static SingleObject <span class="function"><span class="title">getInstance</span></span>()&#123;</span><br><span class="line">       <span class="built_in">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void <span class="function"><span class="title">showMessage</span></span>()&#123;</span><br><span class="line">      System.out.print(<span class="string">"hello"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试类</span></span><br><span class="line"></span><br><span class="line">public class SingletonPatternDemo &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">#不合法的构造函数</span></span><br><span class="line">      <span class="comment">#编译时错误：构造函数 SingleObject() 是不可见的</span></span><br><span class="line">      <span class="comment">#SingleObject object = new SingleObject();</span></span><br><span class="line"></span><br><span class="line">      //获取唯一可用的对象</span><br><span class="line">      SingleObject object = SingleObject.getInstance();</span><br><span class="line"></span><br><span class="line">      //显示消息</span><br><span class="line">      object.showMessage();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-懒汉式，线程不安全"><a href="#1-懒汉式，线程不安全" class="headerlink" title="1.懒汉式，线程不安全"></a>1.懒汉式，线程不安全</h3><p>是否 Lazy 初始化：是<br>是否多线程安全：否<br>实现难度：易</p>
<p>描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁<br>synchronized，所以严格意义上它并不算单例模式。</p>
<p>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</p>
<p>代码实例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance;  </span><br><span class="line">    private <span class="function"><span class="title">Singleton</span></span> ()&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    public static Singleton <span class="function"><span class="title">getInstance</span></span>() &#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == null) &#123;  </span><br><span class="line">        instance = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2、懒汉式，线程安全"><a href="#2、懒汉式，线程安全" class="headerlink" title="2、懒汉式，线程安全"></a>2、懒汉式，线程安全</h3><p>是否 Lazy 初始化：是<br>是否多线程安全：是<br>实现难度：易</p>
<p>描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。</p>
<p>优点：第一次调用才初始化，避免内存浪费。</p>
<p>缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。<br>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</p>
<p>代码实例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance;  </span><br><span class="line">    private <span class="function"><span class="title">Singleton</span></span> ()&#123;&#125;  </span><br><span class="line">    public static synchronized Singleton <span class="function"><span class="title">getInstance</span></span>() &#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == null) &#123;  </span><br><span class="line">        instance = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3、饿汉式"><a href="#3、饿汉式" class="headerlink" title="3、饿汉式"></a>3、饿汉式</h3><p>是否 Lazy 初始化：否<br>是否多线程安全：是<br>实现难度：易</p>
<p>描述：这种方式比较常用，但容易产生垃圾对象。</p>
<p>优点：没有加锁，执行效率会提高。<br>缺点：类加载时就初始化，浪费内存。<br>它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，<br>虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法，<br>但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到<br>lazy loading 的效果。</p>
<p>代码实例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance = new Singleton();  </span><br><span class="line">    private <span class="function"><span class="title">Singleton</span></span> ()&#123;&#125;  </span><br><span class="line">    public static Singleton <span class="function"><span class="title">getInstance</span></span>() &#123;  </span><br><span class="line">       <span class="built_in">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4、双检锁-双重校验锁（DCL，即-double-checked-locking）"><a href="#4、双检锁-双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="4、双检锁/双重校验锁（DCL，即 double-checked locking）"></a>4、双检锁/双重校验锁（DCL，即 double-checked locking）</h3><p>JDK 版本：JDK1.5 起<br>是否 Lazy 初始化：是<br>是否多线程安全：是<br>实现难度：较复杂</p>
<p>描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br>getInstance() 的性能对应用程序很关键。</p>
<p>代码实例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private volatile static Singleton singleton;  </span><br><span class="line">    private <span class="function"><span class="title">Singleton</span></span> ()&#123;&#125;  </span><br><span class="line">    public static Singleton <span class="function"><span class="title">getSingleton</span></span>() &#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == null) &#123;  </span><br><span class="line">        synchronized (Singleton.class) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == null) &#123;  </span><br><span class="line">            singleton = new Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-TCP协议" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/25/TCP协议/" class="article-date">
  	<time datetime="2017-03-25T12:29:13.000Z" itemprop="datePublished">2017-03-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/25/TCP协议/">TCP协议</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>由于TCP协议提供可靠的连接服务，于是采用有保障的三次握手方式来创建一个TCP连接。</p>
<h4 id="三次握手的具体过程如下："><a href="#三次握手的具体过程如下：" class="headerlink" title="三次握手的具体过程如下："></a>三次握手的具体过程如下：</h4><p>客户端发送一个带SYN标志的TCP报文（报文1）到服务器端，表示希望建立一个TCP连接。</p>
<p>服务器发送一个带ACK标志和SYN标志的TCP报文（报文2）给客户端，ACK用于对报文1的回应，SYN用于询问客户<br>端是否准备好进行数据传输。</p>
<p>客户端发送一个带ACK标志的TCP报文（报文3），作为报文2的回应。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。<br>原则是主动关闭的一方（如已传输完所有数据等原因）发送一个FIN报文来表示终止这个方向的连接，<br>收到一个FIN意味着这个方向不再有数据流动，但另一个方向仍能继续发送数据，直到另一个方向也发<br>送FIN报文。</p>
<h4 id="四次挥手的具体过程如下："><a href="#四次挥手的具体过程如下：" class="headerlink" title="四次挥手的具体过程如下："></a>四次挥手的具体过程如下：</h4><p>客户端发送一个FIN报文（报文4）给服务器，表示我将关闭客户端到服务器端这个方向的连接。</p>
<p>服务器收到报文4后，发送一个ACK报文（报文5）给客户端，序号为报文4的序号加1。</p>
<p>服务器发送一个FIN报文（报文6）给客户端，表示自己也将关闭服务器端到客户端这个方向的连接。</p>
<p>客户端收到报文6后，发回一个ACK报文（报文7）给服务器，序号为报文6的序号加1。</p>
<p><img src="/img/TCP建立与断开.jpg" alt=""></p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="Q1-为什么在TCP协议里，建立连接是三次握手，而关闭连接却是四次握手呢？"><a href="#Q1-为什么在TCP协议里，建立连接是三次握手，而关闭连接却是四次握手呢？" class="headerlink" title="Q1  为什么在TCP协议里，建立连接是三次握手，而关闭连接却是四次握手呢？"></a>Q1  为什么在TCP协议里，建立连接是三次握手，而关闭连接却是四次握手呢？</h4><p>因为当处于LISTEN 状态的服务器端SOCKET当收到SYN报文（客户端希望新建一个TCP连接）后，它可以把ACK<br>（应答作用）和SYN（同步作用）放在同一个报文里来发送给客户端。<br>但在关闭TCP连接时，当收到对方的FIN报文时，对方仅仅表示对方没有数据发送给你了，但未必你的所有数据<br>都已经全部发送给了对方，所以你大可不必马上关闭SOCKET（发送一个FIN报文），等你发送完剩余的数据给对<br>方之后，再发送FIN报文给对方来表示你同意现在关闭连接了，所以通常情况下，这里的ACK报文和FIN报文都是分开发送的。</p>
<h4 id="Q2-为什么TIME-WAIT-状态还需要等2-MSL秒之后才能返回到CLOSED-状态呢？"><a href="#Q2-为什么TIME-WAIT-状态还需要等2-MSL秒之后才能返回到CLOSED-状态呢？" class="headerlink" title="Q2 为什么TIME_WAIT 状态还需要等2*MSL秒之后才能返回到CLOSED 状态呢？"></a>Q2 为什么TIME_WAIT 状态还需要等2*MSL秒之后才能返回到CLOSED 状态呢？</h4><p>A2 因为虽然双方都同意关闭连接了，而且握手的4个报文也都发送完毕，按理可以直接回到CLOSED<br>状态（就好比从SYN_SENT 状态到ESTABLISH 状态那样），但是我们必须假想网络是不可靠的，<br>你无法保证你最后发送的ACK报文一定会被对方收到，就是说对方处于LAST_ACK<br>状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT<br>状态的作用就是用来重发可能丢失的ACK报文。</p>
<h4 id="Q3-关闭TCP连接一定需要4次挥手吗？"><a href="#Q3-关闭TCP连接一定需要4次挥手吗？" class="headerlink" title="Q3 关闭TCP连接一定需要4次挥手吗？"></a>Q3 关闭TCP连接一定需要4次挥手吗？</h4><p>A3 不一定，4次挥手关闭TCP连接是最安全的做法。但在有些时候，我们不喜欢TIME_WAIT<br>状态（如当MSL数值设置过大导致服务器端有太多TIME_WAIT状态的TCP连接，减少这些条目数可以更快地关闭连<br>接，为新连接释放更多资源），这时我们可以通过设置SOCKET变量的SO_LINGER标志来避免SOCKET在close()之<br>后进入TIME_WAIT状态，这时将通过发送RST强制终止TCP连接（取代正常的TCP四次握手的终止方式）。但这并<br>不是一个很好的主意，TIME_WAIT 对于我们来说往往是有利的。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-http请求方法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/25/http请求方法/" class="article-date">
  	<time datetime="2017-03-25T08:02:16.000Z" itemprop="datePublished">2017-03-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/25/http请求方法/">http请求方法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>HTTP/1.1协议中共定义了8种HTTP请求方法，HTTP请求方法也被叫做“请求动作”，不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同的响应。</p>
<h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>GET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。<br>GET会方法请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。</p>
<h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。</p>
<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>POST请求会向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，<br>请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资<br>源。</p>
<h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>PUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。</p>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。</p>
<h3 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h3><p>CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。</p>
<h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><p>OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资<br>源所支持的所有HTTP请求方法，该方法会用’*’来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器<br>功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请<br>求，以判断是否有对指定资源的访问权限。 允许</p>
<h3 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h3><p>TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。</p>
<h3 id="HTTP-1-1之后增加的方法"><a href="#HTTP-1-1之后增加的方法" class="headerlink" title="HTTP/1.1之后增加的方法"></a>HTTP/1.1之后增加的方法</h3><p>在HTTP/1.1标准制定之后，又陆续扩展了一些方法。其中使用中较多的是——PATCH 方法：</p>
<p>PATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，<br>同样用于资源的更新。二者有以下两点不同：</p>
<p>但PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。</p>
<p>当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-java中的异常和错误" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/23/java中的异常和错误/" class="article-date">
  	<time datetime="2017-03-23T00:22:49.000Z" itemprop="datePublished">2017-03-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/23/java中的异常和错误/">java种Throwable、Error、Exception、RuntimeException 区别 联系</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Throwable 类是 Java 语言中所有错误或异常的超类。它的两个子类是Error和Exception。</p>
<h3 id="Exception："><a href="#Exception：" class="headerlink" title="Exception："></a>Exception：</h3><p>1．可以是可被控制(checked) 或不可控制的(unchecked) </p>
<p>2．表示一个由程序员导致的错误 </p>
<p>3．应该在应用程序级被处理</p>
<h3 id="Error："><a href="#Error：" class="headerlink" title="Error："></a>Error：</h3><p>1．总是不可控制的(unchecked) </p>
<p>2．经常用来用于表示系统错误或低层资源的错误 </p>
<p>3．如何可能的话，应该在系统级被捕捉</p>
<h3 id="Checked-exception-与-Unchecked-exception"><a href="#Checked-exception-与-Unchecked-exception" class="headerlink" title="Checked exception 与 Unchecked exception"></a>Checked exception 与 Unchecked exception</h3><h4 id="Checked-exception"><a href="#Checked-exception" class="headerlink" title="Checked exception"></a>Checked exception</h4><p>这类异常都是Exception的子类，用异常的向上抛出机制进行处理，假如子类可能<br>产生A异常，那么在父类中也必须throws A异常。可能导致的问题：代码效率低，耦合度过高。</p>
<h4 id="Unchecked-exception"><a href="#Unchecked-exception" class="headerlink" title="Unchecked exception"></a>Unchecked exception</h4><p>这类异常都是RuntimeException的子类，虽然RuntimeException同样也是Exception的子类，但是它们<br>是非凡的，它们不能通过client code来试图解决，所以称为Unchecked exception 。</p>
<h4 id="Checked-Exception与Runtime-Exception-的区别"><a href="#Checked-Exception与Runtime-Exception-的区别" class="headerlink" title="Checked Exception与Runtime Exception 的区别"></a>Checked Exception与Runtime Exception 的区别</h4><p>Java 提供了两种Exception 的模式，一种是执行的时候所产生的Exception (Runtime Exception)，<br>另外一种则是受控制的Exception (Checked Exception)。</p>
<p>所有的Checked Exception 均从java.lang.Exception 继承而来，而Runtime Exception<br>则继承java.lang.RuntimeException 或java.lang.Error (实际上java.lang.RuntimeException<br>的上一层也是java.lang.Exception)。</p>
<p>写代码时很可能会对选择某种形式的Exception 感到困扰，到底应该选择Runtime Exception<br>还是Checked Exception ？</p>
<p>其实，在运作上，可以通过Class 的Method 如何产生某个Exception以及某个程序如何<br>处理这个被产生来的Exception 来了解它们之间的差异，先建立一个Exception：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class CException extends Exception &#123;  </span><br><span class="line">    </span><br><span class="line">    public <span class="function"><span class="title">CException</span></span>() &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public CException(String message) &#123;  </span><br><span class="line">        super(message);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试程序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class TestException &#123;  </span><br><span class="line">    public void method1() throws CException &#123;  </span><br><span class="line">        throw new CException(<span class="string">"Test Exception"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public void method2(String msg) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (msg == null) &#123;  </span><br><span class="line">            throw new NullPointerException(<span class="string">"Message is null"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public void method3() throws CException &#123;  </span><br><span class="line">        method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 以下省略  </span><br><span class="line">    // ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>method1 和 method2 的程序代码内都会产生 Exception，<br>但method3 的程序代码中(大括号内)，并没产生Exception，但在method3 的定义中，暗示了这个 method<br>可能产生CException。</p>
<p>调用 method1() 的程序，由于 method1 会抛出异常 必须将method1() 包含在try 与catch 中，如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Runtest &#123;  </span><br><span class="line">    // ....  </span><br><span class="line">    public static void main(String argv[]) &#123;  </span><br><span class="line">        TestException te = new TestException();  </span><br><span class="line">        try &#123;  </span><br><span class="line">            te.method1();  </span><br><span class="line">        &#125; catch (CException ce) &#123;  </span><br><span class="line">            // ....  </span><br><span class="line">            ce.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    // ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>虽然包含在try 与catch 中，并不表示这段程序码一定会收到CException，<br>但它的用意在于提醒调用者，执行这个method可能产生的意外，而使用者也必须要能针对这个意外做出相对应<br>的处理方式。</p>
<p>当使用者呼叫 method2() 时，并不需要使用try 和catch 将程序码包起来，因为method2 的定义中，<br>并没有throws 任何的Exception ，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Runtest  </span><br><span class="line">&#123;  </span><br><span class="line">// ....  </span><br><span class="line">public static void main(String argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">test</span>Exception te = new <span class="built_in">test</span>Exception();  </span><br><span class="line">  </span><br><span class="line">// 不会产生 Exception  </span><br><span class="line">te.method2(<span class="string">"Hello"</span>);  </span><br><span class="line">  </span><br><span class="line">// 会产生 Exception  </span><br><span class="line">te.method2(null);  </span><br><span class="line">&#125;  </span><br><span class="line">// ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若一个 method 内部抛出的是 RuntimeException，那定义这个 method 时，不需要明确 throws Exception</p>
<p>调用 method 时，若 method 明确  throws Exception，则需要将这个 method 的调用放在 try catch<br>中，对抛出的异常情况进行处理。</p>
<p>调用 method 时，若 method 没有 throws Exception，则不需要将这个 method 的调用放在 try catch<br>中。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-笔试题解析1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/18/笔试题解析1/" class="article-date">
  	<time datetime="2017-03-18T02:55:17.000Z" itemprop="datePublished">2017-03-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/18/笔试题解析1/">笔试题解析1</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h2><h4 id="1-下述解决死锁的方法中，属于死锁预防策略的是？"><a href="#1-下述解决死锁的方法中，属于死锁预防策略的是？" class="headerlink" title="1.下述解决死锁的方法中，属于死锁预防策略的是？"></a>1.下述解决死锁的方法中，属于死锁预防策略的是？</h4><p>银行家算法：避免死锁<br>资源有序分配法：预防死锁<br>资源分配图化简法：检测死锁<br>撤销进程法：解决死锁</p>
<p>死锁：是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用,它们<br>都将无法推进下去.此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程.</p>
<p>产生死锁的原因主要是：<br>　　（1） 因为系统资源不足；<br>　　（2） 进程运行推进的顺序不合适；<br>　　（3） 资源分配不当等；</p>
<p>产生死锁的四个必要条件：<br>　　（1） 互斥条件：一个资源每次只能被一个进程使用。<br>　　（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>　　（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。<br>　　（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。<br>　　这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之<br>　　一不满足，就不会发生死锁。</p>
<h4 id="2-下面代码输出的结果是？"><a href="#2-下面代码输出的结果是？" class="headerlink" title="2.下面代码输出的结果是？"></a>2.下面代码输出的结果是？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class NULL &#123;</span><br><span class="line"></span><br><span class="line">public static void <span class="function"><span class="title">print</span></span>()&#123;</span><br><span class="line">System.out.println(“MTDP”);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">try&#123;</span><br><span class="line">((NULL)null).print(); </span><br><span class="line">&#125;catch(NullPointerException e)&#123;</span><br><span class="line">System.out.println(<span class="string">"NullPointerException"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>null不是对象，它可以看成是指向不确定对象的引用。<br>赋值时，基本类型赋初值不能为null，换而言之，int也没有为空这一说法，如果非要勉强说有，那就是0。<br>而对象赋初值可以将其设为null。<br>null是java的关键字，故不用事先声明它，直接把null作为NULL对象的一个引用，将其实例化，故而有输出。</p>
<h4 id="3-1024-末尾有多少个0"><a href="#3-1024-末尾有多少个0" class="headerlink" title="3.1024! 末尾有多少个0?"></a>3.1024! 末尾有多少个0?</h4><p>末尾0的个数取决于乘法中因子2和5的个数。显然乘法中因子2的个数大于5的个数，所以我们只需统计因子5的个数。<br>是5的倍数的数有： 1024 / 5 = 204个<br>是25的倍数的数有：1024 / 25 = 40个<br>是125的倍数的数有：1024 / 125 = 8个<br>是625的倍数的数有：1024 / 625 = 1个<br>所以1024! 中总共有204+40+8+1=253个因子5。<br>也就是说1024! 末尾有253个0。</p>
<h4 id="4-从n个数中找出最小的k个数-n-gt-gt-k-，最优平均时间复杂度是？"><a href="#4-从n个数中找出最小的k个数-n-gt-gt-k-，最优平均时间复杂度是？" class="headerlink" title="4.从n个数中找出最小的k个数(n &gt;&gt; k)，最优平均时间复杂度是？"></a>4.从n个数中找出最小的k个数(n &gt;&gt; k)，最优平均时间复杂度是？</h4><p>1.先直接排序，再取排序后数据的前k个数。排序算法用最快的堆排序，复杂度也会达到O(N<em>logN)。当k接近于N时，可以用这种算法。<br>2.先排序前k个数，对于后面N-k个数，依次进行插入。时间复杂度为O(k</em>n)。当k很小时，可以用这种算法。<br>3.对前k个数，建立最大堆，对于后面N-k个数，依次和最大堆的最大数比较，如果小于最大数，则替换最大数，并重新建立最大堆。时间复杂度为O(N*logk)。当k和N都很大时，这种算法比前两种算法要快很多。</p>
<h4 id="5-HTTP的会话有四个过程，请选出不是的一个？"><a href="#5-HTTP的会话有四个过程，请选出不是的一个？" class="headerlink" title="5.HTTP的会话有四个过程，请选出不是的一个？"></a>5.HTTP的会话有四个过程，请选出不是的一个？</h4><p>Http会话的四个过程:<br>建立连接，发送请求，返回响应，关闭连接。</p>
<h4 id="6-进程间的通信机制"><a href="#6-进程间的通信机制" class="headerlink" title="6.进程间的通信机制"></a>6.进程间的通信机制</h4><p>管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。<br>进程的亲缘关系通常是指父子进程关系。 </p>
<p>有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。 </p>
<p>信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。<br>消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。<br>信号 ( signal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。<br>共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。<br>套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔试/">笔试</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 明动天下
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>