<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>明动天下</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="java elasticsearch github">
<meta property="og:type" content="website">
<meta property="og:title" content="明动天下">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="明动天下">
<meta property="og:description" content="java elasticsearch github">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="明动天下">
<meta name="twitter:description" content="java elasticsearch github">
  
    <link rel="alternative" href="/atom.xml" title="明动天下" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/me.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">明动天下</a></h1>
		</hgroup>

		
		<p class="header-subtitle">提笔写诗   落笔代码</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">概览</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/wmingstar" title="github">github</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/wmingstar" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/elasticsearch/" style="font-size: 10px;">elasticsearch</a> <a href="/tags/github/" style="font-size: 11.25px;">github</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/linux/" style="font-size: 17.5px;">linux</a> <a href="/tags/python/" style="font-size: 16.25px;">python</a> <a href="/tags/spark/" style="font-size: 12.5px;">spark</a> <a href="/tags/分布式系统/" style="font-size: 10px;">分布式系统</a> <a href="/tags/剑指Offer/" style="font-size: 11.25px;">剑指Offer</a> <a href="/tags/操作系统/" style="font-size: 12.5px;">操作系统</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/笔试/" style="font-size: 10px;">笔试</a> <a href="/tags/算法/" style="font-size: 18.75px;">算法</a> <a href="/tags/面试/" style="font-size: 13.75px;">面试</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">明动天下</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/img/me.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">明动天下</h1>
			</hgroup>
			
			<p class="header-subtitle">提笔写诗   落笔代码</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">概览</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/wmingstar" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/wmingstar" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-offer-3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/10/offer-3/" class="article-date">
  	<time datetime="2017-04-10T00:42:20.000Z" itemprop="datePublished">2017-04-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/10/offer-3/">剑指Offer-3</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。<br>请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>输入：二维数组  正数<br>输出：boolean</p>
<h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public boolean findNum(int[][] nums,int key)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==null || nums.length&lt;1 || nums[0].length&lt;1)&#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean result = <span class="literal">false</span>;</span><br><span class="line">        int i = 0;</span><br><span class="line">        int j = nums[0].length-1;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;nums.length &amp;&amp; j&gt;=0)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i][j]==key)&#123;</span><br><span class="line">                result = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i][j]&gt;key)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int[][] data = &#123;&#123;1,2,3&#125;,&#123;4,7,8&#125;,&#123;5,8,9&#125;&#125;;</span><br><span class="line">        int num = 2;</span><br><span class="line">        Test <span class="built_in">test</span> = new Test();</span><br><span class="line">        boolean result = test.findNum(data,num);</span><br><span class="line">        System.out.print(result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/剑指Offer/">剑指Offer</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-java-访问权限控制符" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/31/java-访问权限控制符/" class="article-date">
  	<time datetime="2017-03-31T03:04:02.000Z" itemprop="datePublished">2017-03-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/31/java-访问权限控制符/">java-访问权限控制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java提供了public, private, protected 三个访问权限修饰词，提供了以下四种访问权限控制机制：</p>
<p>1、包访问权限 （无访问控制符）；</p>
<p>2、Public访问权限；</p>
<p>3、Private访问权限；</p>
<p>4、Protected访问权限；</p>
<h3 id="包访问权限"><a href="#包访问权限" class="headerlink" title="包访问权限"></a>包访问权限</h3><p>包访问权限是Java为了便于程序员开发而给定的一种权限选择。</p>
<p>当 成员方法 或 成员属性 未给定访问权限限制符时，其默认具有该权限。具有该权限的方法 和 成员属性，<br>在包内是完全可见的（注意要与其对象依附在一起），而包外则不可见。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Package accesscontrol</span><br><span class="line"></span><br><span class="line"><span class="comment"># Animal.java</span></span><br><span class="line"></span><br><span class="line">public class Animal</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">　　void bark();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Package accesscontrol</span><br><span class="line"><span class="comment"># Test.java</span></span><br><span class="line"></span><br><span class="line">public class Test</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="title">main</span></span>()</span><br><span class="line"></span><br><span class="line">　　&#123;</span><br><span class="line"></span><br><span class="line">　　 Animal a= new Animal();</span><br><span class="line"></span><br><span class="line">     a.bark();//此处直接访问了Animal类中的bark（）方法</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于Animal类和Test类都被打包在了同一个Package下，Animal中的bark（）方法为包访问权限，<br>故对类Test可见。</p>
<p>对java文件中的类也是如此，若未指定限制符，其默认为包访问权限，只能在包内被使用,包外是无法利用其生<br>成对象的（不可见）。</p>
<p>注意：当决定一个类对包外可见的时候，除了要将类的访问限定符改为public以外，自定义的构造器限定符也<br>必须修改为public，不然将导致外部不可见。</p>
<h3 id="public-权限"><a href="#public-权限" class="headerlink" title="public 权限"></a>public 权限</h3><p>当在方法或域前面显式的给定public限定符的时候，其具有该权限控制。</p>
<p>public权限是最为宽松的一种权限控制，对包的内、外部都是完全可见的。</p>
<p> java最多只允许一个java文件中出现一个public类（该类向外提供接口，并与该java文件的名称完全一致）。</p>
<p>当一个java文件中无一个Public类时，表明其仅供包内使用，对外界不可见！</p>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>类只有包访问权限和public访问权限两类,同时注意 包访问权限和public访问权限<br>这两类不同的类中的 属性和方法的访问。</p>
<p>接口里的变量都隐式声明为public static final，而接口里的方法默认情况下访问权限为public。</p>
<h3 id="Private访问权限"><a href="#Private访问权限" class="headerlink" title="Private访问权限"></a>Private访问权限</h3><p>Private是访问限定最为严格一种权限。</p>
<p>当方法或域为private权限时，表明其只针对该类的内部可见，类的外部（包括同一包内的其它类）<br>是不可见的,并且类和接口不能声明为private。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Animal.java</span></span><br><span class="line"></span><br><span class="line">public class Animal</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">　　private void bark()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Package accesscontrol</span><br><span class="line"></span><br><span class="line"><span class="comment"># Test.java</span></span><br><span class="line"></span><br><span class="line">public class Test</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="title">main</span></span>()</span><br><span class="line"></span><br><span class="line">　　&#123;</span><br><span class="line"></span><br><span class="line">　　Animal a= new Animal();</span><br><span class="line">    <span class="comment"># 此处将造成编译错误，bark（）方法为private方法，仅对Animal类 内部可见，现在在Test类内部。</span></span><br><span class="line">    a.bark();</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="protected访问权限"><a href="#protected访问权限" class="headerlink" title="protected访问权限"></a>protected访问权限</h3><p>protected权限是一种严格程度介于public和private之间的权限，具有prtoected权限的 成员属性 和 方法<br>能被同一个包中的任何其他类访问，也能够被不同包中的子类访问。</p>
<p>protected访问修饰符不能修饰类和接口，方法和成员变量能够声明为protected，但是接口的成员变量和成员<br>方法不能声明为protected，接口的成员变量和成员方法默认为 public。</p>
<p>在面向对象的设计当中，最常用的为public和private访问权限两种。</p>
<p>一般情况下将成员属性定义为private，将方法定义为public。外界使用该类时，通过public方法使用其接口，<br>而具体的成员属性则对外部屏蔽，只能通过类提供的接口间接访问。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Dog&#123;</span><br><span class="line"></span><br><span class="line">　private int age=0;</span><br><span class="line"></span><br><span class="line">  public <span class="built_in">set</span>Age(int num)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">　　age=num+1;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处，age域对外部不可见，要想对其进行操作，必须使用Dog类提供的接口setAge（int num）。</p>
<p>注意到setAge的方法体age=num+1;对用户给出的年龄加1了以后再修改了age属性，这种修改对使用者是不可<br>见的，有时又是非常的必要的！</p>
<p>Java中的访问修饰符（访问控制符）包括：public，protected，default，private。分别代表了不同的访问权限。如果省略，则被视为使用了默认的default作为访问修饰符。<br>　　<br>从字面含义上面理解，很显然，这几个访问控制符（public -&gt; protected -&gt; default -&gt;private）<br>所代表的访问权限是依次递减的。那么，所谓的访问权限是相对什么来说的呢？这个问题的答案就是，这里的<br>权限是针对是不是同一个类、是不是属于同一个包、是不是存在父类子类关系。</p>
<p>public：权限最大，不受类、包等的限制，都可以访问。<br>protected：次于public，限制之处在于如果不再同一个包中，只有和它存在继承关系的子类才可以访问它。<br>default：进一步受限，必须是同一个包才能访问。<br>private：这个就将权限限制在了类中，只有同一个类中的成员才能访问。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-百度面经" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/29/百度面经/" class="article-date">
  	<time datetime="2017-03-29T12:27:39.000Z" itemprop="datePublished">2017-03-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/29/百度面经/">百度面经</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>2017/03/29  下午参加了百度云计算部门的面试</p>
<h3 id="1-Elasticsearch-的系统架构及选主机制"><a href="#1-Elasticsearch-的系统架构及选主机制" class="headerlink" title="1.Elasticsearch 的系统架构及选主机制"></a>1.Elasticsearch 的系统架构及选主机制</h3><p><img src="/img/elasticsearch架构图.png" alt=""></p>
<h4 id="各部分功能（待续）"><a href="#各部分功能（待续）" class="headerlink" title="各部分功能（待续）"></a>各部分功能（待续）</h4><p>   多个节点运行elasticsearch服务可以组成一个集群，在这个集群里面有一个主节点(master),<br>elasticsearch是去中心化的，所以这里的主节点是动态选举出来的，不存在单点故障。</p>
<p>   在同一个子网内，只需要在每个节点上设置相同的集群名,elasticsearch就会自动的把这些集群名相同<br>的节点组成一个集群。节点和节点之间通讯以及节点之间的数据分配和平衡全部由elasticsearch自动管理。</p>
<p>   每一个运行实例称为一个节点,每一个运行实例既可以在同一机器上,也可以在不同的机器上。<br>所谓运行实例,就是一个ES服务器进程，在测试环境中可以在一台服务器上运行多个服务器进程，在生产环境中<br>建议每台服务器运行一个服务器进程。</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>Elasticsearch 看名字就能大概了解下它是一个弹性的搜索引擎。首先弹性隐含的意思是分布式，<br>单机系统是没法弹起来的，然后加上灵活的伸缩机制，就是这里的 Elastic 包含的意思。<br>它的搜索存储功能主要是 Lucene 提供的，Lucene 相当于其存储引擎，<br>它在之上封装了索引，查询，以及分布式相关的接口。</p>
<p>集群（Cluster）：一组拥有共同的 cluster name 的节点。</p>
<p>节点（Node) ：集群中的一个 Elasticearch 实例。</p>
<p>索引（Index)： 相当于关系数据库中的database概念，一个集群中可以包含多个索引。这个是个逻辑概念。</p>
<p>主分片（Primary shard）： 索引的子集，索引可以切分成多个分片，分布到不同的集群节点上。分片对应的是 Lucene 中的索引。</p>
<p>副本分片（Replica shard）：每个主分片可以有一个或者多个副本。</p>
<p>类型（Type）：相当于数据库中的table概念，mapping是针对 Type 的，同一个索引里可以包含多个 Type。</p>
<p>文档（Document)： 相当于数据库中的row。</p>
<p>字段（Field）：相当于数据库中的column。</p>
<h4 id="服务发现以及选主-ZenDiscovery"><a href="#服务发现以及选主-ZenDiscovery" class="headerlink" title="服务发现以及选主 ZenDiscovery"></a>服务发现以及选主 ZenDiscovery</h4><p>   分布式系统要解决的第一个问题就是节点之间互相发现以及选主的机制。如果使用了 Zookeeper/Etcd<br>这样的成熟的服务发现工具，这两个问题都一并解决了。<br>但 Elasticsearch 并没有依赖这样的工具，带来的好处是部署服务的成本和复杂度降低了，<br>不用预先依赖一个服务发现的集群，缺点当然是将复杂度带入了 Elasticsearch 内部。</p>
<p>1.节点启动后先ping（这里的ping是 Elasticsearch 的一个RPC命令。如果<br>discovery.zen.ping.unicast.hosts 有设置，则ping设置中的host，否则尝试ping localhost 的几个端口，<br>Elasticsearch 支持同一个主机启动多个节点）</p>
<p>2.Ping的response会包含该节点的基本信息以及该节点认为的master节点。</p>
<p>3.选举开始，先从各节点认为的master中选，规则很简单，按照id的字典序排序，取第一个。</p>
<p>4.如果各节点都没有认为的master，则从所有节点中选择，规则同上。这里有个限制条件就是<br>discovery.zen.minimum_master_nodes，如果节点数达不到最小值的限制，则循环上述过程，直到节点数足够<br>可以开始选举。</p>
<p>5.最后选举结果是肯定能选举出一个master，如果只有一个local节点那就选出的是自己。</p>
<p>6.如果当前节点是master，则开始等待节点数达到 minimum_master_nodes，然后提供服务。</p>
<p>7.如果当前节点不是master，则尝试加入master。</p>
<p>Elasticsearch 将以上服务发现以及选主的流程叫做 ZenDiscovery 。<br>由于它支持任意数目的集群（1-N）,所以不能像 Zookeeper/Etcd 那样限制节点必须是奇数，<br>也就无法用投票的机制来选主。<br>而是通过一个规则，只要所有的节点都遵循同样的规则，得到的信息都是对等的，选出来的主节点肯定是一致<br>的。但分布式系统的问题就出在信息不对等的情况，这时候很容易出现脑裂（Split-Brain）的问题，大多数解<br>决方案就是设置一个quorum值，要求可用节点必须大于quorum（一般是超过半数节点），才能对外提供服务。<br>而 Elasticsearch 中，这个quorum的配置就是 discovery.zen.minimum_master_nodes 。 说到这里要吐槽下Elasticsearch 的方法和变量命名，它的方法和配置中的master指的是master的候选节点，也就是说可能成为master的节点，并不是表示当前的master。</p>
<h3 id="2-判断一个单向链表是否有环，若是循环链表，找出链表入口-加以证明"><a href="#2-判断一个单向链表是否有环，若是循环链表，找出链表入口-加以证明" class="headerlink" title="2.判断一个单向链表是否有环，若是循环链表，找出链表入口;加以证明"></a>2.判断一个单向链表是否有环，若是循环链表，找出链表入口;加以证明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static Node findEntryNode(Node head)&#123;</span><br><span class="line">        if(head==null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Node slow = head;</span><br><span class="line">        Node quick = head;</span><br><span class="line">        boolean flag = false;</span><br><span class="line">        while (quick.next.next!=null)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            quick = quick.next.next;</span><br><span class="line">            if(slow == quick)&#123;</span><br><span class="line">                flag = true;</span><br><span class="line">                System.out.println(&quot;有环&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!flag)&#123;</span><br><span class="line">            System.out.println(&quot;无环&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = head;</span><br><span class="line">        while (slow!=quick)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            quick=quick.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test01();</span><br><span class="line">        test02();</span><br><span class="line">        test03();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6</span><br><span class="line">    private static void test01() &#123;</span><br><span class="line">        Node n1 = new Node(1);</span><br><span class="line">        Node n2 = new Node(2);</span><br><span class="line">        Node n3 = new Node(3);</span><br><span class="line">        Node n4 = new Node(4);</span><br><span class="line">        Node n5 = new Node(5);</span><br><span class="line">        Node n6 = new Node(6);</span><br><span class="line"></span><br><span class="line">        n1.next = n2;</span><br><span class="line">        n2.next = n3;</span><br><span class="line">        n3.next = n4;</span><br><span class="line">        n4.next = n5;</span><br><span class="line">        n5.next = n6;</span><br><span class="line">        Node result = findEntryNode(n1);</span><br><span class="line">        if (result != null) &#123;</span><br><span class="line">            System.out.println(result.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6</span><br><span class="line">    //       ^        |</span><br><span class="line">    //       |        |</span><br><span class="line">    //       +--------+</span><br><span class="line">    private static void test02() &#123;</span><br><span class="line">        Node n1 = new Node(1);</span><br><span class="line">        Node n2 = new Node(2);</span><br><span class="line">        Node n3 = new Node(3);</span><br><span class="line">        Node n4 = new Node(4);</span><br><span class="line">        Node n5 = new Node(5);</span><br><span class="line">        Node n6 = new Node(6);</span><br><span class="line"></span><br><span class="line">        n1.next = n2;</span><br><span class="line">        n2.next = n3;</span><br><span class="line">        n3.next = n4;</span><br><span class="line">        n4.next = n5;</span><br><span class="line">        n5.next = n6;</span><br><span class="line">        n6.next = n3;</span><br><span class="line">        Node result = findEntryNode(n1);</span><br><span class="line">        if (result != null) &#123;</span><br><span class="line">            System.out.println(result.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 &lt;-+</span><br><span class="line">    //                |   |</span><br><span class="line">    //                +---+</span><br><span class="line">    private static void test03() &#123;</span><br><span class="line">        Node n1 = new Node(1);</span><br><span class="line">        Node n2 = new Node(2);</span><br><span class="line">        Node n3 = new Node(3);</span><br><span class="line">        Node n4 = new Node(4);</span><br><span class="line">        Node n5 = new Node(5);</span><br><span class="line">        Node n6 = new Node(6);</span><br><span class="line"></span><br><span class="line">        n1.next = n2;</span><br><span class="line">        n2.next = n3;</span><br><span class="line">        n3.next = n4;</span><br><span class="line">        n4.next = n5;</span><br><span class="line">        n5.next = n6;</span><br><span class="line">        n6.next = n6;</span><br><span class="line"></span><br><span class="line">        Node result = findEntryNode(n1);</span><br><span class="line">        if (result != null) &#123;</span><br><span class="line">            System.out.println(result.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h3><p>当快慢指针（slow、fast）相遇时，slow指针肯定没有遍历完链表，而fast指针已经在环内循环了<br>n（n&gt;=1）圈。假设slow指针走了 s 步，则fast指针走了 2s 步。同时，fast指针的步数还等于 s<br>加上在环上多转的 n 圈，设环长为 r，则满足如下关系表达式： </p>
<p>2s = s + nr; 所以可知：s = nr; </p>
<p>假设链表的头节点到“环的尾节点“的长度为L（注意，L不一定是链表长度），环的入口节点与相遇点的<br>距离为 b ，链表的头节点到环入口的距离为a，则满足如下关系表达式：<br>          a + b = s = nr;<br>可得：    a + b = (n - 1)r + r = (n - 1)r + (L - a)<br>进一步得：a = (n - 1)r + (L -a - b)<br>结论： </p>
<p><1> (L - a -b)为相遇点到环入口节点的距离，即从相遇点开始向前移动<br> (L -a -b)步后，会再次到达环入口节点;</1></p>
<p><2> 从链表的头节点到环入口节点的距离 ＝ (n - 1) * 环内循环 ＋ 相遇点到环入口点的距离; </2></p>
<p><3> 于是从链表头与相遇点分别设一个指针，每次各走一步，两个指针必定相遇，且相遇第一点为环入口点。</3></p>
<h3 id="3-线程与进程的区别"><a href="#3-线程与进程的区别" class="headerlink" title="3.线程与进程的区别"></a>3.线程与进程的区别</h3><h4 id="线程与进程的概念"><a href="#线程与进程的概念" class="headerlink" title="线程与进程的概念"></a>线程与进程的概念</h4><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和<br>调度的一个独立单位。</p>
<p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。</p>
<p>线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它<br>可与同属一个进程的其他的线程共享进程所拥有的全部资源.</p>
<p>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</p>
<p>相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的<br>栈空间，拥有独立的执行序列。</p>
<p>在串行程序基础上引入线程和进程是为了提高程序的并发度，从而提高程序运行效率和响应时间。</p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。<br>进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响；<br>而线程只是一个进程中的不同执行路径。</p>
<p>线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，<br>所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</p>
<p>但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>
<p>1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程；<br>2) 线程的划分尺度小于进程，使得多线程程序的并发性高；<br>3) 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率；<br>4) 线程在执行过程中与进程还是有区别的，每个独立的线程有一个程序运行的入口、顺序执行序列和<br>程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。<br>但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。</p>
<h3 id="多进程与多线程"><a href="#多进程与多线程" class="headerlink" title="多进程与多线程"></a>多进程与多线程</h3><p>进程就是一个程序运行的时候被CPU抽象出来的，一个程序运行后被抽象为一个进程；线程是从一个进程里<br>面分割出来的，由于CPU处理进程的时候是采用时间片轮转的方式，所以要把一个大个进程给分割成多个线程，<br>例如：下载文件时，共100个文件，用 10个线程， 文件就被分成了10份来同时下载 1-10 占一个线程 11<br>-20占一个线程,依次类推,线程越多,文件就被分的越多,同时下载 当然速度也就越快。</p>
<p>进程是程序在计算机上的一次执行活动，当你运行一个程序，你就启动了一个进程。</p>
<p>程序只是一组指令的有序集合，它本身没有任何运行的含义，只是一个静态实体。<br>而进程则不同，它是程序在某个数据集上的执行，是一个动态实体。它因创建而产生，因调度而运行，因等待资源或事件而被处于等待状态，因完成任务而被撤消，反映了一个程序在一定的数据集上运行的动态过程。</p>
<p>进程是操作系统分配资源的独立单位。在Windows下，进程又被细化为线程，也就是一个进程下有多个能独立运行的更小的单位。线程(Thread)是进程的一个实体，是CPU调度和分派的基本单位。线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
<p>线程和进程的关系是：线程是属于进程的，线程运行在进程空间内，同一进程所产生的线程共享同一内存空间，当进程退出时该进程所产生的线程都会被强制退出并清除。<br>线程可与属于同一进程的其它线程共享进程所拥有的全部资源，但是其本身基本上不拥有系统资源，只拥有一点在运行中必不可少的信息(如程序计数器、一组寄存器和栈)。</p>
<p>在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，这便是多任务。现代的<br>操作系统几乎都是多任务操作系统，能够同时管理多个进程的运行。</p>
<p>多任务带来的好处是明显的，比如你可以边听mp3边上网，与此同时甚至可以将下载的文档打印出来，而这些任<br>务之间丝毫不会相互干扰。那么这里就涉及到并行的问题，俗话说，一心不能二用，这对计算机也一样，原则<br>上一个CPU只能分配给一个进程，以便运行这个进程。</p>
<p>实现并发技术相当复杂，最容易理解的是“时间片轮转进程调度算法”，它的思想简单介绍如下：在操作系统的<br>管理下，所有正在运行的进程轮流使用CPU，每个进程允许占用CPU的时间非常短(比如10毫秒)，这样用户根本<br>感觉不出来CPU是在轮流为多个进程服务，就好象所有的进程都在不间断地运行一样，但实际上在任何一个时间<br>内有且仅有一个进程占有CPU。</p>
<p>如果一台计算机有多个CPU，如果进程数小于CPU数，则不同的进程可以分配给不同的CPU来运行，这样，多个进<br>程就是真正同时运行的，这便是并行。但如果进程数大于CPU数，则仍然需要使用并发技术。</p>
<p>在Windows中，进行CPU分配是以线程为单位的，一个进程可能由多个线程组成，这时情况更加复杂，但简单地说，有如下关系：<br>总线程数&lt;= CPU数量：并行运行<br>总线程数&gt; CPU数量：并发运行<br>并行运行的效率显然高于并发运行，所以在多CPU的计算机中，多任务的效率比较高。但是，如果在多CPU计算<br>机中只运行一个进程(线程)，就不能发挥多CPU的优势。</p>
<p>多任务操作系统(如Windows)的基本原理是:操作系统将CPU的时间片分配给多个线程,每个线程在操作系统指定<br>的时间片内完成(注意,这里的多个线程是分属于不同进程的)。<br>操作系统不断的从一个线程的执行切换到另一个线程的执行,<br>如此往复,宏观上看来,就好像是多个线程在一起执行。由于这多个线程分属于不同的进程,因此在我<br>们看来,就好像是多个进程在同时执行,这样就实现了多任务。</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>多进程、单线程，多数UNIX(及类UNIX的Linux)是这种操作系统；<br>多进程、多线程，Win32(Windows NT/2000/XP等)、Solaris 2.x和OS/2都是这种操作系统；</p>
<h3 id="死锁的产生、预防和避免"><a href="#死锁的产生、预防和避免" class="headerlink" title="死锁的产生、预防和避免"></a>死锁的产生、预防和避免</h3><p>死锁是由于并发进程只能按互斥方式访问临界资源等多种因素引起的，并且是一种与执行时间和速度密切相关<br>的错误现象。</p>
<p>死锁的一般定义：若在一个进程集合中，每一个进程都在等待一个永远不会发生的事件而形成一个永久的阻塞<br>状态，这种阻塞状态就是死锁。</p>
<p>线程A需要资源X，而线程B需要资源Y，而双方都掌握有对方所要的资源，这种情况称为死锁（deadlock）</p>
<h4 id="死锁的产生条件："><a href="#死锁的产生条件：" class="headerlink" title="死锁的产生条件："></a>死锁的产生条件：</h4><p>1.互斥：系统存在这样一种资源，它在某个时刻只能被分配给一个执行者（也称为线程）使用；<br>2.占有并等待：当请求的资源已被占用从而导致执行者阻塞时，资源占用者不但无需释放该资源，<br>              而且还可以继续请求更多资源；<br>3.不可剥夺(no preemption)：已经分配的资源在其宿主没有释放之前不允许被剥夺；<br>4.循环等待(circular waiting)：系统中存在多个（大于2个）进程形成的封闭的进程链，<br>                             链中的每个进程都在等待它的下一个进程所占有的资源；</p>
<h4 id="死锁的预防："><a href="#死锁的预防：" class="headerlink" title="死锁的预防："></a>死锁的预防：</h4><p>因为独占资源必须以互斥方式进行访问，所以要预防死锁只能从破坏后三个条件下手了。<br>1.破坏 占有并等待 条件：</p>
<p>要破坏这个条件，就要求每个进程必须一次性的请求它们所需要的所有资源，若无法全部获取就等待，直到满<br>足为止，也可以采用事务机制，确保可以回滚，即把获取、释放资源做成原子性的。这个方法实现起来可能会<br>比较困难，因为某些情况下，进程并不能事先知道自己需要哪些资源，也有时候并不需要分配到所有资源就可以运行。</p>
<p>2.破坏 不可剥夺 条件：<br>一个已占有资源的进程若要再申请新的资源，它必须先释放已占有的资源；若随后再需要这些资源，需要重新<br>申请。</p>
<p>3.破坏循环等待条件：<br>将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作。 </p>
<h4 id="死锁的避免："><a href="#死锁的避免：" class="headerlink" title="死锁的避免："></a>死锁的避免：</h4><p>死锁的预防是通过破坏产生条件来阻止死锁的产生，但这种方法破坏了系统的并行性和并发性。</p>
<p>死锁产生的前三个条件是死锁产生的必要条件，也就是说要产生死锁必须具备的条件，而不是存在这3个条件就一定产生死锁，那么只要在逻辑上回避了第四个条件就可以避免死锁。</p>
<p>避免死锁采用的是允许前三个条件存在，但通过合理的资源分配算法来确保永远不会形成环形等待的封闭进程<br>链，从而避免死锁。<br>该方法支持多个进程的并发执行，为了避免死锁，系统动态的确定是否分配一个资源给请求的进程。<br>方法如下：<br>1.如果一个进程的当前请求的资源会导致死锁，系统拒绝启动该进程；<br>2.如果一个资源的分配会导致下一步的死锁，系统就拒绝本次的分配；<br> 显然要避免死锁，必须事先知道系统拥有的资源数量及其属性。</p>
<h3 id="spark内存溢出问题如何解决"><a href="#spark内存溢出问题如何解决" class="headerlink" title="spark内存溢出问题如何解决"></a>spark内存溢出问题如何解决</h3><h3 id="深拷贝-与-浅拷贝的区别-（java）"><a href="#深拷贝-与-浅拷贝的区别-（java）" class="headerlink" title="深拷贝 与 浅拷贝的区别 （java）"></a>深拷贝 与 浅拷贝的区别 （java）</h3><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>对象拷贝(Object Copy)就是将一个对象的属性拷贝到另一个相同类类型的对象中去。在程序中拷贝对象<br>是很常见的，主要是为了在新的上下文环境中复用对象的部分或全部数据。<br>Java中有三种类型的对象拷贝：浅拷贝(Shallow Copy)、深拷贝(Deep Copy)、延迟拷贝(Lazy Copy)。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>浅拷贝：使用一个已知实例对新创建实例的成员变量逐个赋值，这个方式被称为浅拷贝。</p>
<p>深拷贝：当一个类的拷贝构造方法，不仅要复制对象的所有非引用成员变量值，还要为引用类型的成员变量创<br>建新的实例，并且初始化为形式参数实例值。这个方式称为深拷贝。</p>
<p>也就是说浅拷贝只复制一个对象，传递引用，不能复制实例。<br>而深拷贝对对象内部的引用均复制，它是创建一个新的实例，并且复制实例。</p>
<p>对于浅拷贝当对象的成员变量是基本数据类型时，两个对象的成员变量已有存储空间，赋值运算传递值，所以<br>浅拷贝能够复制实例。但是当对象的成员变量是引用数据类型时，就不能实现对象的复制了。</p>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。<br>如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，<br>因此如果其中一个对象改变了这个地址，就会影响到另一个对象。<br><img src="/img/浅拷贝1.png" alt=""><br>在上图中，SourceObject有一个int类型的属性 “field1”和一个引用类型属性”refObj”（引用ContainedObject类型的对象）。<br>当对SourceObject做浅拷贝时，创建了CopiedObject，它有一个包含”field1”拷贝值的属性”field2”以及仍指向refObj本身<br>的引用。由于”field1”是基本类型，所以只是将它的值拷贝给”field2”，但是由于”refObj”是一个引用类型,<br>所以CopiedObject指向”refObj”相同的地址。因此对SourceObject中的”refObj”所做的任何改变都会影响到CopiedObject。</p>
<h4 id="浅拷贝的实现"><a href="#浅拷贝的实现" class="headerlink" title="浅拷贝的实现"></a>浅拷贝的实现</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Subject &#123;</span><br><span class="line"> </span><br><span class="line">   private String name; </span><br><span class="line"></span><br><span class="line">   public Subject(String s) &#123; </span><br><span class="line">      name = s; </span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   public String <span class="function"><span class="title">getName</span></span>() &#123; </span><br><span class="line">      <span class="built_in">return</span> name; </span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   public void <span class="built_in">set</span>Name(String s) &#123; </span><br><span class="line">      name = s; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Student implements Cloneable &#123; </span><br><span class="line"> </span><br><span class="line">   // 对象引用 </span><br><span class="line">   private Subject subj; </span><br><span class="line"> </span><br><span class="line">   private String name; </span><br><span class="line"> </span><br><span class="line">   public Student(String s, String sub) &#123; </span><br><span class="line">      name = s; </span><br><span class="line">      subj = new Subject(sub); </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   public Subject <span class="function"><span class="title">getSubj</span></span>() &#123; </span><br><span class="line">      <span class="built_in">return</span> subj; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   public String <span class="function"><span class="title">getName</span></span>() &#123; </span><br><span class="line">      <span class="built_in">return</span> name; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   public void <span class="built_in">set</span>Name(String s) &#123; </span><br><span class="line">      name = s; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   /** </span><br><span class="line">    *  重写<span class="built_in">clone</span>()方法 </span><br><span class="line">    * @<span class="built_in">return</span> </span><br><span class="line">    */ </span><br><span class="line">   public Object <span class="function"><span class="title">clone</span></span>() &#123; </span><br><span class="line">      //浅拷贝 </span><br><span class="line">      try &#123; </span><br><span class="line">         // 直接调用父类的<span class="built_in">clone</span>()方法</span><br><span class="line">         <span class="built_in">return</span> super.clone(); </span><br><span class="line">      &#125; catch (CloneNotSupportedException e) &#123; </span><br><span class="line">         <span class="built_in">return</span> null; </span><br><span class="line">      &#125; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class CopyTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 原始对象</span><br><span class="line">        Student stud = new Student(<span class="string">"John"</span>, <span class="string">"Algebra"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Original Object: "</span> + stud.getName() + <span class="string">" - "</span> + stud.getSubj().getName());</span><br><span class="line"></span><br><span class="line">        // 拷贝对象</span><br><span class="line">        Student clonedStud = (Student) stud.clone();</span><br><span class="line">        System.out.println(<span class="string">"Cloned Object: "</span> + clonedStud.getName() + <span class="string">" - "</span> + clonedStud.getSubj().getName());</span><br><span class="line"></span><br><span class="line">        // 原始对象和拷贝对象是否一样：</span><br><span class="line">        System.out.println(<span class="string">"Is Original Object the same with Cloned Object: "</span> + (stud == clonedStud));</span><br><span class="line">        // 原始对象和拷贝对象的name属性是否一样</span><br><span class="line">        System.out.println(<span class="string">"Is Original Object's field name the same with Cloned Object: "</span> + (stud.getName() == clonedStud.getName()));</span><br><span class="line">        // 原始对象和拷贝对象的subj属性是否一样</span><br><span class="line">        System.out.println(<span class="string">"Is Original Object's field subj the same with Cloned Object: "</span> + (stud.getSubj() == clonedStud.getSubj()));</span><br><span class="line"></span><br><span class="line">        stud.setName(<span class="string">"Dan"</span>);</span><br><span class="line">        stud.getSubj().setName(<span class="string">"Physics"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Original Object after it is updated: "</span> + stud.getName() + <span class="string">" - "</span> + stud.getSubj().getName());</span><br><span class="line">        System.out.println(<span class="string">"Cloned Object after updating original object: "</span> + clonedStud.getName() + <span class="string">" - "</span> + clonedStud.getSubj().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果输出"><a href="#结果输出" class="headerlink" title="结果输出"></a>结果输出</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Original Object: John - Algebra</span><br><span class="line">Cloned Object: John - Algebra</span><br><span class="line">Is Original Object the same with Cloned Object: <span class="literal">false</span></span><br><span class="line">Is Original Object<span class="string">'s field name the same with Cloned Object: true</span><br><span class="line">Is Original Object'</span>s field subj the same with Cloned Object: <span class="literal">true</span></span><br><span class="line">Original Object after it is updated: Dan - Physics</span><br><span class="line">Cloned Object after updating original object: John - Physics</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我让要拷贝的类Student实现了Clonable接口并重写Object类的clone()方法，然后在方法内部调用super.clone()<br>方法。从输出结果中我们可以看到，对原始对象stud的”name”属性所做的改变并没有影响到拷贝对象clonedStud，但是对引用对象<br>subj的”name”属性所做的改变影响到了拷贝对象clonedStud。</p>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅<br>拷贝速度较慢并且花销较大。<br><img src="/img/深拷贝1.png" alt=""><br>在上图中，SourceObject有一个int类型的属性 “field1”和一个引用类型属性”refObj1”（引用ContainedObject类型的对象）<br>。当对SourceObject做深拷贝时，创建了CopiedObject，它有一个包含”field1”拷贝值的属性”field2”以及包含”refObj1”拷贝值的<br>引用类型属性”refObj2” 。因此对SourceObject中的”refObj”所做的任何改变都不会影响到CopiedObject。</p>
<p>下面是实现深拷贝的一个例子。只是在浅拷贝的例子上做了一点小改动，Subject 和CopyTest 类都没有变化。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Student implements Cloneable &#123; </span><br><span class="line">   // 对象引用 </span><br><span class="line">   private Subject subj; </span><br><span class="line"> </span><br><span class="line">   private String name; </span><br><span class="line"> </span><br><span class="line">   public Student(String s, String sub) &#123; </span><br><span class="line">      name = s; </span><br><span class="line">      subj = new Subject(sub); </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   public Subject <span class="function"><span class="title">getSubj</span></span>() &#123; </span><br><span class="line">      <span class="built_in">return</span> subj; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   public String <span class="function"><span class="title">getName</span></span>() &#123; </span><br><span class="line">      <span class="built_in">return</span> name; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   public void <span class="built_in">set</span>Name(String s) &#123; </span><br><span class="line">      name = s; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   /** </span><br><span class="line">    * 重写<span class="built_in">clone</span>()方法 </span><br><span class="line">    * </span><br><span class="line">    * @<span class="built_in">return</span> </span><br><span class="line">    */ </span><br><span class="line">   public Object <span class="function"><span class="title">clone</span></span>() &#123; </span><br><span class="line">      // 深拷贝，创建拷贝类的一个新对象，这样就和原始对象相互独立</span><br><span class="line">      Student s = new Student(name, subj.getName()); </span><br><span class="line">      <span class="built_in">return</span> s; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果输出-1"><a href="#结果输出-1" class="headerlink" title="结果输出"></a>结果输出</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Original Object: John - Algebra</span><br><span class="line">Cloned Object: John - Algebra</span><br><span class="line">Is Original Object the same with Cloned Object: <span class="literal">false</span></span><br><span class="line">Is Original Object<span class="string">'s field name the same with Cloned Object: true</span><br><span class="line">Is Original Object'</span>s field subj the same with Cloned Object: <span class="literal">false</span></span><br><span class="line">Original Object after it is updated: Dan - Physics</span><br><span class="line">Cloned Object after updating original object: John - Algebra</span><br></pre></td></tr></table></figure>
<p>很容易发现clone()方法中的一点变化。因为它是深拷贝，所以你需要创建拷贝类的一个对象。因为在Student<br>类中有对象引用，所以需要在Student类中实现Cloneable接口并且重写clone方法。</p>
<h3 id="Hashmap与Hashtable的区别"><a href="#Hashmap与Hashtable的区别" class="headerlink" title="Hashmap与Hashtable的区别"></a>Hashmap与Hashtable的区别</h3><p>HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点： </p>
<p>1)HashMap允许键和值是null，而Hashtable不允许键或者值是null。 </p>
<p>2)Hashtable是同步的，而HashMap不是，因此HashMap更适合于单线程环境，而Hashtable适合于多线程环境。 </p>
<p>3）HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator(列举)迭代器不是<br>fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），<br>将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则<br>不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。<br>这条同样也是Enumeration和Iterator的区别。一般认为Hashtable是一个遗留的<br>类。如果你寻求在迭代的时候修改Map，你应该使用CocurrentHashMap</p>
<h3 id="数据库-事务的特性"><a href="#数据库-事务的特性" class="headerlink" title="数据库 事务的特性"></a>数据库 事务的特性</h3><p>事务(Transaction)是并发控制的基本单位。</p>
<p>所谓事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。例如，<br>银行转帐工作：从一个帐号扣款并使另一个帐号增款，这两个操作要么都执行，要么都不执行。</p>
<p>数据库事务必须具备ACID特性：<br>Atomic（原子性）、Consistency（一致性）、Isolation（隔离性）和Durability（持久性）的英文缩写。</p>
<p>原子性：指整个数据库事务是不可分割的工作单位。只有所有的操作执行成功，才算整个事务成功；<br>事务中任何一个SQL语句执行失败，那么已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务<br>前的状态。</p>
<p>　 一致性：指数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。例如对银行转帐事务，不管事务成功还是失败，应该保证事务结束后ACCOUNTS表中Tom和Jack的存款总额为2000元。</p>
<p>　 隔离性：指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。</p>
<p>　 持久性：指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。</p>
<p>事务的（ACID）特性是由关系数据库管理系统（RDBMS，数据库系统）来实现的。数据库管理系统采用日志来保证事务的原子性、一致性和持久性。日志记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据日志，撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。</p>
<p>数据库管理系统采用锁机制来实现事务的隔离性。当多个事务同时更新数据库中相同的数据时，只允许持有锁的事务能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-java-单例模式" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/27/java-单例模式/" class="article-date">
  	<time datetime="2017-03-27T11:43:03.000Z" itemprop="datePublished">2017-03-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/27/java-单例模式/">java-单例模式</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访<br>问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>1、单例类只能有一个实例。<br>2、单例类必须自己创建自己的唯一实例。<br>3、单例类必须给所有其他对象提供这一实例。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<h3 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决"></a>主要解决</h3><p>一个全局使用的类频繁地创建与销毁。</p>
<h3 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h3><p>当您想控制实例数目，节省系统资源的时候。</p>
<h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p>
<h3 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h3><p>构造函数是私有的。</p>
<h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p> 1、一个党只能有一个主席。<br> 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作<br> 一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）2、避免对资源的多重占用（比如写文件操作）</p>
<p>###缺点<br>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p> 1、要求生产唯一序列号。<br> 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</p>
<p>注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 SingleObject 类</span></span><br><span class="line">public class SingleObject&#123;</span><br><span class="line">   <span class="comment">#创建一个SingleObject 对象</span></span><br><span class="line">   private static SingleObject instance = new SingleObject();</span><br><span class="line">   </span><br><span class="line">   private <span class="function"><span class="title">SingleObject</span></span>()&#123;&#125;</span><br><span class="line">   </span><br><span class="line">   public static SingleObject <span class="function"><span class="title">getInstance</span></span>()&#123;</span><br><span class="line">       <span class="built_in">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void <span class="function"><span class="title">showMessage</span></span>()&#123;</span><br><span class="line">      System.out.print(<span class="string">"hello"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试类</span></span><br><span class="line"></span><br><span class="line">public class SingletonPatternDemo &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">#不合法的构造函数</span></span><br><span class="line">      <span class="comment">#编译时错误：构造函数 SingleObject() 是不可见的</span></span><br><span class="line">      <span class="comment">#SingleObject object = new SingleObject();</span></span><br><span class="line"></span><br><span class="line">      //获取唯一可用的对象</span><br><span class="line">      SingleObject object = SingleObject.getInstance();</span><br><span class="line"></span><br><span class="line">      //显示消息</span><br><span class="line">      object.showMessage();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-懒汉式，线程不安全"><a href="#1-懒汉式，线程不安全" class="headerlink" title="1.懒汉式，线程不安全"></a>1.懒汉式，线程不安全</h3><p>是否 Lazy 初始化：是<br>是否多线程安全：否<br>实现难度：易</p>
<p>描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁<br>synchronized，所以严格意义上它并不算单例模式。</p>
<p>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</p>
<p>代码实例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance;  </span><br><span class="line">    private <span class="function"><span class="title">Singleton</span></span> ()&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    public static Singleton <span class="function"><span class="title">getInstance</span></span>() &#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == null) &#123;  </span><br><span class="line">        instance = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2、懒汉式，线程安全"><a href="#2、懒汉式，线程安全" class="headerlink" title="2、懒汉式，线程安全"></a>2、懒汉式，线程安全</h3><p>是否 Lazy 初始化：是<br>是否多线程安全：是<br>实现难度：易</p>
<p>描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。</p>
<p>优点：第一次调用才初始化，避免内存浪费。</p>
<p>缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。<br>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</p>
<p>代码实例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance;  </span><br><span class="line">    private <span class="function"><span class="title">Singleton</span></span> ()&#123;&#125;  </span><br><span class="line">    public static synchronized Singleton <span class="function"><span class="title">getInstance</span></span>() &#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == null) &#123;  </span><br><span class="line">        instance = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3、饿汉式"><a href="#3、饿汉式" class="headerlink" title="3、饿汉式"></a>3、饿汉式</h3><p>是否 Lazy 初始化：否<br>是否多线程安全：是<br>实现难度：易</p>
<p>描述：这种方式比较常用，但容易产生垃圾对象。</p>
<p>优点：没有加锁，执行效率会提高。<br>缺点：类加载时就初始化，浪费内存。<br>它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，<br>虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法，<br>但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到<br>lazy loading 的效果。</p>
<p>代码实例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance = new Singleton();  </span><br><span class="line">    private <span class="function"><span class="title">Singleton</span></span> ()&#123;&#125;  </span><br><span class="line">    public static Singleton <span class="function"><span class="title">getInstance</span></span>() &#123;  </span><br><span class="line">       <span class="built_in">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4、双检锁-双重校验锁（DCL，即-double-checked-locking）"><a href="#4、双检锁-双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="4、双检锁/双重校验锁（DCL，即 double-checked locking）"></a>4、双检锁/双重校验锁（DCL，即 double-checked locking）</h3><p>JDK 版本：JDK1.5 起<br>是否 Lazy 初始化：是<br>是否多线程安全：是<br>实现难度：较复杂</p>
<p>描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br>getInstance() 的性能对应用程序很关键。</p>
<p>代码实例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private volatile static Singleton singleton;  </span><br><span class="line">    private <span class="function"><span class="title">Singleton</span></span> ()&#123;&#125;  </span><br><span class="line">    public static Singleton <span class="function"><span class="title">getSingleton</span></span>() &#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == null) &#123;  </span><br><span class="line">        synchronized (Singleton.class) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == null) &#123;  </span><br><span class="line">            singleton = new Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-TCP协议" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/25/TCP协议/" class="article-date">
  	<time datetime="2017-03-25T12:29:13.000Z" itemprop="datePublished">2017-03-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/25/TCP协议/">TCP协议</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>由于TCP协议提供可靠的连接服务，于是采用有保障的三次握手方式来创建一个TCP连接。</p>
<h4 id="三次握手的具体过程如下："><a href="#三次握手的具体过程如下：" class="headerlink" title="三次握手的具体过程如下："></a>三次握手的具体过程如下：</h4><p>客户端发送一个带SYN标志的TCP报文（报文1）到服务器端，表示希望建立一个TCP连接。</p>
<p>服务器发送一个带ACK标志和SYN标志的TCP报文（报文2）给客户端，ACK用于对报文1的回应，SYN用于询问客户<br>端是否准备好进行数据传输。</p>
<p>客户端发送一个带ACK标志的TCP报文（报文3），作为报文2的回应。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。<br>原则是主动关闭的一方（如已传输完所有数据等原因）发送一个FIN报文来表示终止这个方向的连接，<br>收到一个FIN意味着这个方向不再有数据流动，但另一个方向仍能继续发送数据，直到另一个方向也发<br>送FIN报文。</p>
<h4 id="四次挥手的具体过程如下："><a href="#四次挥手的具体过程如下：" class="headerlink" title="四次挥手的具体过程如下："></a>四次挥手的具体过程如下：</h4><p>客户端发送一个FIN报文（报文4）给服务器，表示我将关闭客户端到服务器端这个方向的连接。</p>
<p>服务器收到报文4后，发送一个ACK报文（报文5）给客户端，序号为报文4的序号加1。</p>
<p>服务器发送一个FIN报文（报文6）给客户端，表示自己也将关闭服务器端到客户端这个方向的连接。</p>
<p>客户端收到报文6后，发回一个ACK报文（报文7）给服务器，序号为报文6的序号加1。</p>
<p><img src="/img/TCP建立与断开.jpg" alt=""></p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="Q1-为什么在TCP协议里，建立连接是三次握手，而关闭连接却是四次握手呢？"><a href="#Q1-为什么在TCP协议里，建立连接是三次握手，而关闭连接却是四次握手呢？" class="headerlink" title="Q1  为什么在TCP协议里，建立连接是三次握手，而关闭连接却是四次握手呢？"></a>Q1  为什么在TCP协议里，建立连接是三次握手，而关闭连接却是四次握手呢？</h4><p>因为当处于LISTEN 状态的服务器端SOCKET当收到SYN报文（客户端希望新建一个TCP连接）后，它可以把ACK<br>（应答作用）和SYN（同步作用）放在同一个报文里来发送给客户端。<br>但在关闭TCP连接时，当收到对方的FIN报文时，对方仅仅表示对方没有数据发送给你了，但未必你的所有数据<br>都已经全部发送给了对方，所以你大可不必马上关闭SOCKET（发送一个FIN报文），等你发送完剩余的数据给对<br>方之后，再发送FIN报文给对方来表示你同意现在关闭连接了，所以通常情况下，这里的ACK报文和FIN报文都是分开发送的。</p>
<h4 id="Q2-为什么TIME-WAIT-状态还需要等2-MSL秒之后才能返回到CLOSED-状态呢？"><a href="#Q2-为什么TIME-WAIT-状态还需要等2-MSL秒之后才能返回到CLOSED-状态呢？" class="headerlink" title="Q2 为什么TIME_WAIT 状态还需要等2*MSL秒之后才能返回到CLOSED 状态呢？"></a>Q2 为什么TIME_WAIT 状态还需要等2*MSL秒之后才能返回到CLOSED 状态呢？</h4><p>A2 因为虽然双方都同意关闭连接了，而且握手的4个报文也都发送完毕，按理可以直接回到CLOSED<br>状态（就好比从SYN_SENT 状态到ESTABLISH 状态那样），但是我们必须假想网络是不可靠的，<br>你无法保证你最后发送的ACK报文一定会被对方收到，就是说对方处于LAST_ACK<br>状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT<br>状态的作用就是用来重发可能丢失的ACK报文。</p>
<h4 id="Q3-关闭TCP连接一定需要4次挥手吗？"><a href="#Q3-关闭TCP连接一定需要4次挥手吗？" class="headerlink" title="Q3 关闭TCP连接一定需要4次挥手吗？"></a>Q3 关闭TCP连接一定需要4次挥手吗？</h4><p>A3 不一定，4次挥手关闭TCP连接是最安全的做法。但在有些时候，我们不喜欢TIME_WAIT<br>状态（如当MSL数值设置过大导致服务器端有太多TIME_WAIT状态的TCP连接，减少这些条目数可以更快地关闭连<br>接，为新连接释放更多资源），这时我们可以通过设置SOCKET变量的SO_LINGER标志来避免SOCKET在close()之<br>后进入TIME_WAIT状态，这时将通过发送RST强制终止TCP连接（取代正常的TCP四次握手的终止方式）。但这并<br>不是一个很好的主意，TIME_WAIT 对于我们来说往往是有利的。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 明动天下
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>