<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>明动天下</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="java elasticsearch github">
<meta property="og:type" content="website">
<meta property="og:title" content="明动天下">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="明动天下">
<meta property="og:description" content="java elasticsearch github">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="明动天下">
<meta name="twitter:description" content="java elasticsearch github">
  
    <link rel="alternative" href="/atom.xml" title="明动天下" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/me.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">明动天下</a></h1>
		</hgroup>

		
		<p class="header-subtitle">提笔写诗   落笔代码</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">概览</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/wmingstar" title="github">github</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/wmingstar" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/elasticsearch/" style="font-size: 10px;">elasticsearch</a> <a href="/tags/github/" style="font-size: 11.25px;">github</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/linux/" style="font-size: 17.5px;">linux</a> <a href="/tags/python/" style="font-size: 16.25px;">python</a> <a href="/tags/spark/" style="font-size: 12.5px;">spark</a> <a href="/tags/分布式系统/" style="font-size: 10px;">分布式系统</a> <a href="/tags/剑指Offer/" style="font-size: 11.25px;">剑指Offer</a> <a href="/tags/操作系统/" style="font-size: 12.5px;">操作系统</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/笔试/" style="font-size: 10px;">笔试</a> <a href="/tags/算法/" style="font-size: 18.75px;">算法</a> <a href="/tags/面试/" style="font-size: 13.75px;">面试</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">明动天下</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/img/me.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">明动天下</h1>
			</hgroup>
			
			<p class="header-subtitle">提笔写诗   落笔代码</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">概览</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/wmingstar" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/wmingstar" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-java-jvm" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/11/java-jvm/" class="article-date">
  	<time datetime="2017-03-11T08:04:52.000Z" itemprop="datePublished">2017-03-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/11/java-jvm/">java-jvm</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/img/jvm常见问题.jpg" alt=""></p>
<h2 id="一、Java引用的四种状态："><a href="#一、Java引用的四种状态：" class="headerlink" title="一、Java引用的四种状态："></a>一、Java引用的四种状态：</h2><h3 id="强引用："><a href="#强引用：" class="headerlink" title="强引用："></a>强引用：</h3><p>用的最广。我们平时写代码时，new一个Object存放在堆内存(Dog a = new Dog())，<br>然后用一个引用指向它，这就是强引用。</p>
<p>如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。</p>
<h3 id="软引用："><a href="#软引用：" class="headerlink" title="软引用："></a>软引用：</h3><p>如果一个对象只具有软引用，则内存空间足够时，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。（备注：如果内存不足，随时有可能被回收。）</p>
<p>只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>
<h3 id="弱引用："><a href="#弱引用：" class="headerlink" title="弱引用："></a>弱引用：</h3><p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。</p>
<p>每次执行GC的时候，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过<br>，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p>
<h3 id="虚引用："><a href="#虚引用：" class="headerlink" title="虚引用："></a>虚引用：</h3><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p>
<p>虚引用主要用来跟踪对象被垃圾回收器回收的活动。</p>
<h2 id="java中内存划分"><a href="#java中内存划分" class="headerlink" title="java中内存划分"></a>java中内存划分</h2><p>java程序运行时，需要在内存中分配空间，为了提高运算效率，就对数据进行了不同空间的划分，每一片区域都有特定的处理数据的方式和内存管理方式<br><img src="/img/java内存划分.jpg" alt=""><br>上面这张图就是jvm运行时的状态。具体划分为如下5个内存空间：（非常重要）</p>
<p>堆内存：存放所有new出来的东西（对象）</p>
<p>方法区：存储被虚拟机加载的类信息、常量、静态常量、静态方法等。<br>运行时常量池（方法区的一部分）</p>
<p>虚拟机栈：（栈内存）为虚拟机执行java方法服务：<br>方法被调用时创建栈帧–&gt;局部变量表-&gt;局部变量、对象引用</p>
<p>程序计数器：保证线程切换后能恢复到原来的执行位置</p>
<p>本地方法栈：为虚拟机执使用到的Native方法服务</p>
<h3 id="GC对它们的回收"><a href="#GC对它们的回收" class="headerlink" title="GC对它们的回收"></a>GC对它们的回收</h3><p>内存区域中的程序计数器、虚拟机栈、本地方法栈这3个区域随着线程而生，线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈的操作，每个栈帧中分配多少内存基本是在类结构确定下来时就已知的。在这几个区域不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟着回收了。</p>
<h3 id="GC回收的主要对象"><a href="#GC回收的主要对象" class="headerlink" title="GC回收的主要对象"></a>GC回收的主要对象</h3><p>而Java堆和方法区则不同，一个接口中的多个实现类需要的内存可能不同，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，GC关注的也是这部分内存，后面的文章中如果涉及到“内存”分配与回收也仅指着一部分内存。</p>
<h3 id="1-Java堆：即堆内存（线程共享）"><a href="#1-Java堆：即堆内存（线程共享）" class="headerlink" title="1.Java堆：即堆内存（线程共享）"></a>1.Java堆：即堆内存（线程共享）</h3><p>（1）堆是java虚拟机所管理的内存区域中最大的一块，java堆是被所有线程共享的内存区域，在java虚拟机启动时创建，堆内存的唯一目的就是存放对象实例，几乎所有的对象实例都在堆内存分配。</p>
<p>（2）堆是GC管理的主要区域，从垃圾回收的角度看，由于现在的垃圾收集器都是采用的分代收集算法，<br>因此java堆还可以初步细分为新生代和老年代。</p>
<p>（3）Java虚拟机规定堆可以处于物理上不连续的内存空间中，只要逻辑上连续的即可。在实现上既可以是固定的，也可以是可动态扩展的。如果在堆内存没有完成实例分配，并且堆大小也无法扩展，就会抛出OutOfMemoryError异常。</p>
<h3 id="2-方法区：（线程共享）"><a href="#2-方法区：（线程共享）" class="headerlink" title="2.方法区：（线程共享）"></a>2.方法区：（线程共享）</h3><p>（1）用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>（2）Sun HotSpot虚拟机把方法区叫做永久代（Permanent Generation），<br>方法区中最重要的部分是运行时常量池。</p>
<h4 id="运行时常量池："><a href="#运行时常量池：" class="headerlink" title="运行时常量池："></a>运行时常量池：</h4><p>（1）运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时就会抛出OutOfMemoryError异常。 </p>
<h3 id="3-程序计数器：（线程私有）"><a href="#3-程序计数器：（线程私有）" class="headerlink" title="3.程序计数器：（线程私有）"></a>3.程序计数器：（线程私有）</h3><p>每个线程拥有一个程序计数器，在线程创建时创建，</p>
<p>指向下一条指令的地址</p>
<p>执行本地方法时，其值为undefined</p>
<p>说的通俗一点，我们知道，Java是支持多线程的，程序先去执行A线程，执行到一半，然后就去执行B线程，然后又跑回来接着执行A线程，那程序是怎么记住A线程已经执行到哪里了呢？这就需要程序计数器了。因此，为了线程切换后能够恢复到正确的执行位置，每条线程都有一个独立的程序计数器，这块儿属于“线程私有”的内存。</p>
<h3 id="4-Java虚拟机栈：（线程私有）"><a href="#4-Java虚拟机栈：（线程私有）" class="headerlink" title="4.Java虚拟机栈：（线程私有）"></a>4.Java虚拟机栈：（线程私有）</h3><p>每个方法被调用的时候都会创建一个栈帧，用于存储局部变量表、操作栈、动态链接、方法出口等信息。局部变量表存放的是：编译器可知的基本数据类型、对象引用类型。</p>
<p>每个方法被调用直到执行完成的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。</p>
<p>在Java虚拟机规范中，对这个区域规定了两种异常情况：</p>
<p>（1）如果线程请求的栈深度太深，超出了虚拟机所允许的深度，就会出现StackOverFlowError（比如无限递归。因为每一层栈帧都占用一定空间，而 Xss 规定了栈的最大空间，超出这个值就会报错）</p>
<p>（2）虚拟机栈可以动态扩展，如果扩展到无法申请足够的内存空间，会出现OOM</p>
<h3 id="5-本地方法栈："><a href="#5-本地方法栈：" class="headerlink" title="5.本地方法栈："></a>5.本地方法栈：</h3><p>（1）本地方法栈与java虚拟机栈作用非常类似，其区别是：java虚拟机栈是为虚拟机执行java方法服务的，而本地方法栈则为虚拟机执使用到的Native方法服务。</p>
<p>（2）Java虚拟机没有对本地方法栈的使用和数据结构做强制规定，Sun HotSpot虚拟机就把java虚拟机栈和本地方法栈合二为一。</p>
<p>（3）本地方法栈也会抛出StackOverFlowError和OutOfMemoryError。</p>
<h2 id="三、Java对象在内存中的状态："><a href="#三、Java对象在内存中的状态：" class="headerlink" title="三、Java对象在内存中的状态："></a>三、Java对象在内存中的状态：</h2><h3 id="可达的-可触及的："><a href="#可达的-可触及的：" class="headerlink" title="可达的/可触及的："></a>可达的/可触及的：</h3><p>Java对象被创建后，如果被一个或多个变量引用，那就是可达的。即从根节点可以触及到这个对象。<br>其实就是从根节点扫描，只要这个对象在引用链中，那就是可触及的。</p>
<h3 id="可恢复的："><a href="#可恢复的：" class="headerlink" title="可恢复的："></a>可恢复的：</h3><p>Java对象不再被任何变量引用就进入了可恢复状态。</p>
<p>在回收该对象之前，该对象的finalize()方法进行资源清理。如果在finalize()方法中重新让变量引用该对象，则该对象再次变为可达状态，否则该对象进入不可达状态</p>
<h3 id="不可达的"><a href="#不可达的" class="headerlink" title="不可达的"></a>不可达的</h3><p>Java对象不被任何变量引用，且系统在调用对象的finalize()方法后依然没有使该对象变成可达状态（该对象依然没有被变量引用），那么该对象将变成不可达状态。<br>当Java对象处于不可达状态时，系统才会真正回收该对象所占有的资源。</p>
<h2 id="四、判断对象死亡的两种常用算法："><a href="#四、判断对象死亡的两种常用算法：" class="headerlink" title="四、判断对象死亡的两种常用算法："></a>四、判断对象死亡的两种常用算法：</h2><p>当对象不被引用的时候，这个对象就是死亡的，等待GC进行回收。</p>
<h3 id="引用计数算法："><a href="#引用计数算法：" class="headerlink" title="引用计数算法："></a>引用计数算法：</h3><h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h4><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>
<h4 id="但是："><a href="#但是：" class="headerlink" title="但是："></a>但是：</h4><p>主流的java虚拟机并没有选用引用计数算法来管理内存，其中最主要的原因是：它很难解决对象之间相互循环引用的问题。</p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>算法的实现简单，判定效率也高，大部分情况下是一个不错的算法。很多地方应用到它</p>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>引用和去引用伴随加法和减法，影响性能<br>致命的缺陷：对于循环引用的对象无法进行回收</p>
<h3 id="根搜索算法：（jvm采用的算法）"><a href="#根搜索算法：（jvm采用的算法）" class="headerlink" title="根搜索算法：（jvm采用的算法）"></a>根搜索算法：（jvm采用的算法）</h3><h4 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h4><p>设立若干种根对象，当任何一个根对象（GC Root）到某一个对象均不可达时，<br>则认为这个对象是可以被回收的。</p>
<h4 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h4><p>这里提到，设立若干种根对象，当任何一个根对象到某一个对象均不可达时，则认为这个对象是可以被回收的。我们在后面介绍标记-清理算法/标记整理算法时，也会一直强调从根节点开始，对所有可达对象做一次标记，那什么叫做可达呢？</p>
<h4 id="可达性分析："><a href="#可达性分析：" class="headerlink" title="可达性分析："></a>可达性分析：</h4><p>从根（GC Roots）的对象作为起始点，开始向下搜索，搜索所走过的路径称为“引用链”，当一个对象到GC<br>Roots没有任何引用链相连（用图论的概念来讲，就是从GCRoots到这个对象不可达）时，则证明此对象是<br>不可用的。</p>
<p><img src="/img/可达性分析.jpg" alt=""></p>
<p>如上图所示，ObjectD和ObjectE是互相关联的，但是由于GC roots到这两个对象不可达，所以最终D和E还是会<br>被当做GC的对象，上图若是采用引用计数法，则A-E五个对象都不会被回收。</p>
<h4 id="根（GC-Roots）："><a href="#根（GC-Roots）：" class="headerlink" title="根（GC Roots）："></a>根（GC Roots）：</h4><p>说到GC roots（GC根），在JAVA语言中，可以当做GC roots的对象有以下几种：</p>
<p>1、栈（栈帧中的本地变量表）中引用的对象。</p>
<p>2、方法区中的静态成员。</p>
<p>3、方法区中的常量引用的对象（全局变量）</p>
<p>4、本地方法栈中JNI（一般说的Native方法）引用的对象。</p>
<p>注：第一和第四种都是指的方法的本地变量表，第二种表达的意思比较清晰，第三种主要指的是声明为final的常量值。</p>
<p>在根搜索算法的基础上，现代虚拟机的实现当中，垃圾搜集的算法主要有三种，分别是标记-清除算法、复制算法、标记-整理算法。这三种算法都扩充了根搜索算法，不过它们理解起来还是非常好理解的。</p>
<h2 id="五、垃圾回收算法："><a href="#五、垃圾回收算法：" class="headerlink" title="五、垃圾回收算法："></a>五、垃圾回收算法：</h2><h3 id="1、标记-清除算法："><a href="#1、标记-清除算法：" class="headerlink" title="1、标记-清除算法："></a>1、标记-清除算法：</h3><h4 id="概念：-2"><a href="#概念：-2" class="headerlink" title="概念："></a>概念：</h4><p>标记阶段：先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象；</p>
<p>清除阶段：清除所有未被标记的对象。</p>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><p>标记和清除的过程效率不高（标记和清除都需要从头遍历到尾）</p>
<p>标记清除后会产生大量不连续的碎片。</p>
<h3 id="2、复制算法：（新生代的GC）"><a href="#2、复制算法：（新生代的GC）" class="headerlink" title="2、复制算法：（新生代的GC）"></a>2、复制算法：（新生代的GC）</h3><h4 id="概念：-3"><a href="#概念：-3" class="headerlink" title="概念："></a>概念：</h4><p>将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，然后清除正在使用的内存块中的所有对象。</p>
<h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><p>这样使得每次都是对整个半区进行回收，内存分配时也就不用考虑内存碎片等情况<br>只要移动堆顶指针，按顺序分配内存即可，实现简单，运行效率高</p>
<h4 id="缺点：空间的浪费"><a href="#缺点：空间的浪费" class="headerlink" title="缺点：空间的浪费"></a>缺点：空间的浪费</h4><p>从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行。</p>
<p>现在的商业虚拟机都采用这种收集算法来回收新生代，新生代中的对象98%都是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块比较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是说，每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的空间会被浪费。</p>
<p>当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖于老年代进行分配担保，所以大对象直接进入老年代。整个过程如下图所示：</p>
<p><img src="/img/分代回收.png" alt=""></p>
<h3 id="3、标记-整理算法：（老年代的GC）"><a href="#3、标记-整理算法：（老年代的GC）" class="headerlink" title="3、标记-整理算法：（老年代的GC）"></a>3、标记-整理算法：（老年代的GC）</h3><p>复制算法在对象存活率高的时候要进行较多的复制操作，效率将会降低，所以在老年代中一般不能直接选用这种算法。</p>
<h4 id="概念：-4"><a href="#概念：-4" class="headerlink" title="概念："></a>概念：</h4><p>标记阶段：先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象</p>
<h4 id="整理阶段：将将所有的存活对象压缩到内存的一端；之后，清理边界外所有的空间"><a href="#整理阶段：将将所有的存活对象压缩到内存的一端；之后，清理边界外所有的空间" class="headerlink" title="整理阶段：将将所有的存活对象压缩到内存的一端；之后，清理边界外所有的空间"></a>整理阶段：将将所有的存活对象压缩到内存的一端；之后，清理边界外所有的空间</h4><h4 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h4><p>不会产生内存碎片。</p>
<h4 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h4><p>在标记的基础之上还需要进行对象的移动，成本相对较高，效率也不高。</p>
<h4 id="它们的区别如下：（-gt-表示前者要优于后者，-表示两者效果一样）"><a href="#它们的区别如下：（-gt-表示前者要优于后者，-表示两者效果一样）" class="headerlink" title="它们的区别如下：（&gt;表示前者要优于后者，=表示两者效果一样）"></a>它们的区别如下：（&gt;表示前者要优于后者，=表示两者效果一样）</h4><p>（1）效率：复制算法 &gt; 标记/整理算法 &gt; 标记/清除算法<br>（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。</p>
<p>（2）内存整齐度：复制算法=标记/整理算法&gt;标记/清除算法。</p>
<p>（3）内存利用率：标记/整理算法=标记/清除算法&gt;复制算法。</p>
<p>注1：标记-整理算法不仅可以弥补标记-清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价。</p>
<p>注2：可以看到标记/清除算法是比较落后的算法了，但是后两种算法却是在此基础上建立的。</p>
<p>注3：时间与空间不可兼得。</p>
<h3 id="4、分代收集算法："><a href="#4、分代收集算法：" class="headerlink" title="4、分代收集算法："></a>4、分代收集算法：</h3><p>当前商业虚拟机的GC都是采用的“分代收集算法”，这并不是什么新的思想，只是根据对象的存活周期的不同将内存划分为几块儿。一般是把Java堆分为新生代和老年代：短命对象归为新生代，长命对象归为老年代。</p>
<h4 id="存活率低：少量对象存活，适合复制算法："><a href="#存活率低：少量对象存活，适合复制算法：" class="headerlink" title="存活率低：少量对象存活，适合复制算法："></a>存活率低：少量对象存活，适合复制算法：</h4><p>在新生代中，每次GC时都发现有大批对象死去，只有少量存活（新生代中98%的对象都是“朝生夕死”），那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成GC。</p>
<h4 id="存活率高：大量对象存活，适合用标记-清理-标记-整理："><a href="#存活率高：大量对象存活，适合用标记-清理-标记-整理：" class="headerlink" title="存活率高：大量对象存活，适合用标记-清理/标记-整理："></a>存活率高：大量对象存活，适合用标记-清理/标记-整理：</h4><p>在老年代中，因为对象存活率高、没有额外空间对他进行分配担保，就必须使用“标记-清理”/“标记-整理”算法进行GC。<br>注：老年代的对象中，有一小部分是因为在新生代回收时，老年代做担保，进来的对象；绝大部分对象是因为很多次GC都没有被回收掉而进入老年代。</p>
<h2 id="六、垃圾收集器："><a href="#六、垃圾收集器：" class="headerlink" title="六、垃圾收集器："></a>六、垃圾收集器：</h2><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p>
<p>虽然我们在对各种收集器进行比较，但并非为了挑出一个最好的收集器。因为直到现在位置还没有最好的收集器出现，更加没有万能的收集器，所以我们选择的只是对具体应用最合适的收集器。</p>
<h3 id="1、Serial收集器：（串行收集器）"><a href="#1、Serial收集器：（串行收集器）" class="headerlink" title="1、Serial收集器：（串行收集器）"></a>1、Serial收集器：（串行收集器）</h3><p>这个收集器是一个单线程的收集器，但它的单线程的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程（Stop-The-World：将用户正常工作的线程全部暂停掉），直到它收集结束。收集器的运行过程如下图所示：<br><img src="/img/serial收集器.png" alt=""></p>
<p>上图中：<br>新生代采用复制算法，Stop-The-World<br>老年代采用标记-整理算法，Stop-The-World</p>
<p>当它进行GC工作的时候，虽然会造成Stop-The-World，但它存在有存在的原因：正是因为它的简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，没有线程交互的开销，专心做GC，自然可以获得最高的单线程收集效率。所以Serial收集器对于运行在client模式下是一个很好的选择（它依然是虚拟机运行在client模式下的默认新生代收集器）。</p>
<h3 id="2、ParNew收集器：Serial收集器的多线程版本（使用多条线程进行GC）"><a href="#2、ParNew收集器：Serial收集器的多线程版本（使用多条线程进行GC）" class="headerlink" title="2、ParNew收集器：Serial收集器的多线程版本（使用多条线程进行GC）"></a>2、ParNew收集器：Serial收集器的多线程版本（使用多条线程进行GC）</h3><p>ParNew收集器是Serial收集器的多线程版本。</p>
<p>它是运行在server模式下的首选新生代收集器，除了Serial收集器外，目前只有它能与CMS收集器配合工作。<br>CMS收集器是一个被认为具有划时代意义的并发收集器，因此如果有一个垃圾收集器能和它一起搭配使用让其更加完美，那这个收集器必然也是一个不可或缺的部分了。收集器的运行过程如下图所示：<br><img src="/img/parnew收集器.png" alt=""></p>
<p>上图中：<br>新生代采用复制算法，Stop-The-World<br>老年代采用标记-整理算法，Stop-The-World</p>
<h3 id="3、ParNew-Scanvenge收集器"><a href="#3、ParNew-Scanvenge收集器" class="headerlink" title="3、ParNew Scanvenge收集器"></a>3、ParNew Scanvenge收集器</h3><p>类似ParNew，但更加关注吞吐量。目标是：达到一个可控制吞吐量的收集器。</p>
<p>停顿时间和吞吐量不可能同时调优。我们一方买希望停顿时间少，另外一方面希望吞吐量高，其实这是矛盾的。因为：在GC的时候，垃圾回收的工作总量是不变的，如果将停顿时间减少，那频率就会提高；既然频率提高了，说明就会频繁的进行GC，那吞吐量就会减少，性能就会降低。</p>
<p>吞吐量：CPU用于用户代码的时间/CPU总消耗时间的比值，即=运行用户代码的时间/(运行用户代码时间+垃圾收集时间)。比如，虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>
<h3 id="4、G1收集器："><a href="#4、G1收集器：" class="headerlink" title="4、G1收集器："></a>4、G1收集器：</h3><p>是当今收集器发展的最前言成果之一，直到jdk1.7，sun公司才认为它达到了足够成熟的商用程度。</p>
<h4 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h4><p>(1)它最大的优点是结合了空间整合，不会产生大量的碎片，也降低了进行gc的频率。</p>
<p>(2)可以让使用者明确指令指定停顿时间。（可以指定一个最小时间，超过这个时间，就不会进行回收了）</p>
<p>它有了这么高效率的原因之一就是：对垃圾回收进行了划分优先级的操作，这种有优先级的区域回收方式保证了它的高效率。</p>
<p>如果你的应用追求停顿，那G1现在已经可以作为一个可尝试的选择；如果你的应用追求吞吐量，那G1并不会为你带来什么特别的好处。</p>
<h4 id="注：以上所有的收集器当中，当执行GC时，都会stop-the-world，但是下面的CMS收集器却不会这样。"><a href="#注：以上所有的收集器当中，当执行GC时，都会stop-the-world，但是下面的CMS收集器却不会这样。" class="headerlink" title="注：以上所有的收集器当中，当执行GC时，都会stop the world，但是下面的CMS收集器却不会这样。"></a>注：以上所有的收集器当中，当执行GC时，都会stop the world，但是下面的CMS收集器却不会这样。</h4><h3 id="5、CMS收集器：（老年代收集器）"><a href="#5、CMS收集器：（老年代收集器）" class="headerlink" title="5、CMS收集器：（老年代收集器）"></a>5、CMS收集器：（老年代收集器）</h3><p>CMS收集器（Concurrent Mark Sweep：并发标记清除）是一种以获取最短回收停顿时间为目标的收集器。<br>适合应用在互联网站或者B/S系统的服务器上，这类应用尤其重视服务器的响应速度，希望系统停顿时间最短。</p>
<p>CMS收集器运行过程：（着重实现了标记的过程）</p>
<p>（1）初始标记</p>
<p>　　根可以直接关联到的对象</p>
<p>　　速度快</p>
<p>（2）并发标记（和用户线程一起）</p>
<p>　　主要标记过程，标记全部对象</p>
<p>（3）重新标记</p>
<p>　　由于并发标记时，用户线程依然运行，因此在正式清理前，再做修正</p>
<p>（4）并发清除（和用户线程一起）</p>
<p>　　基于标记结果，直接清理对象</p>
<p><img src="/img/cms收集器.png" alt=""></p>
<p>上图中，初始标记和重新标记时，需要stop the world。<br>整个过程中耗时最长的是并发标记和并发清除，这两个过程都可以和用户线程一起工作。</p>
<h4 id="优点：-4"><a href="#优点：-4" class="headerlink" title="优点："></a>优点：</h4><p>并发收集，低停顿</p>
<h4 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h4><p>（1）导致用户的执行速度降低。</p>
<p>（2）无法处理浮动垃圾。因为它采用的是标记-清除算法。有可能有些垃圾在标记之后，需要等到下一次GC才会被回收。如果CMS运行期间无法满足程序需要，那么就会临时启用Serial Old收集器来重新进行老年代的收集。</p>
<p>（3）由于采用的是标记-清除算法，那么就会产生大量的碎片。往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次full GC。</p>
<h2 id="七、Java堆内存划分："><a href="#七、Java堆内存划分：" class="headerlink" title="七、Java堆内存划分："></a>七、Java堆内存划分：</h2><p>根据对象的存活率（年龄），Java对内存划分为3种：新生代、老年代、永久代：</p>
<h3 id="1、新生代："><a href="#1、新生代：" class="headerlink" title="1、新生代："></a>1、新生代：</h3><p>比如我们在方法中去new一个对象，那这方法调用完毕后，对象就会被回收，这就是一个典型的新生代对象。 </p>
<p>现在的商业虚拟机都采用这种收集算法来回收新生代，新生代中的对象98%都是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块比较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是说，每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的空间会被浪费。</p>
<p>当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖于老年代进行分配担保，所以大对象直接进入老年代。同时，长期存活的对象将进入老年代（虚拟机给每个对象定义一个年龄计数器）。</p>
<p>来看下面这张图：<br><img src="/img/java内存堆划分.jpg" alt=""></p>
<h3 id="2、老年代："><a href="#2、老年代：" class="headerlink" title="2、老年代："></a>2、老年代：</h3><p>在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中;而且大对象直接进入老年代。</p>
<h3 id="3、永久代："><a href="#3、永久代：" class="headerlink" title="3、永久代："></a>3、永久代：</h3><p>即方法区。</p>
<h3 id="GC分为两种：Minor-GC和Full-GC"><a href="#GC分为两种：Minor-GC和Full-GC" class="headerlink" title="GC分为两种：Minor GC和Full GC"></a>GC分为两种：Minor GC和Full GC</h3><h3 id="Minor-GC："><a href="#Minor-GC：" class="headerlink" title="Minor GC："></a>Minor GC：</h3><p>Minor GC是发生在新生代中的垃圾收集动作，采用的是复制算法。</p>
<p>对象在Eden和From区出生后，在经过一次Minor GC后，如果对象还存活，并且能够被to区所容纳，那么在使用复制算法时这些存活对象就会被复制到to区域，然后清理掉Eden区和from区，并将这些对象的年龄设置为1，以后对象在Survivor区每熬过一次Minor GC，就将对象的年龄+1，当对象的年龄达到某个值时（默认是15岁，可以通过参数 –XX:MaxTenuringThreshold设置），这些对象就会成为老年代。</p>
<p>但这也是不一定的，对于一些较大的对象（即需要分配一块较大的连续内存空间）则是直接进入老年代</p>
<h3 id="Full-GC："><a href="#Full-GC：" class="headerlink" title="Full GC："></a>Full GC：</h3><p>Full GC是发生在老年代的垃圾收集动作，采用的是标记-清除/整理算法。</p>
<p>老年代里的对象几乎都是在Survivor区熬过来的，不会那么容易死掉。因此Full GC发生的次数不会有Minor GC那么频繁，并且做一次Full GC要比做一次Minor GC的时间要长。</p>
<p>另外，如果采用的是标记-清除算法的话会产生许多碎片，此后如果需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次GC。</p>
<h2 id="八、类加载机制："><a href="#八、类加载机制：" class="headerlink" title="八、类加载机制："></a>八、类加载机制：</h2><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p>
<h3 id="类加载的过程："><a href="#类加载的过程：" class="headerlink" title="类加载的过程："></a>类加载的过程：</h3><p>包括加载、链接（含验证、准备、解析）、初始化<br><img src="/img/类的加载过程.png" alt=""></p>
<h3 id="1、加载："><a href="#1、加载：" class="headerlink" title="1、加载："></a>1、加载：</h3><p>类加载指的是将类的class文件读入内存，并为之创建一个java.lang.Class对象，作为方法区这个类的数据访问的入口。</p>
<p>也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。具体包括以下三个部分：</p>
<p>（1）通过类的全名产生对应类的二进制数据流。（根据early load原理，如果没找到对应的类文件，<br>只有在类实际使用时才会抛出错误）</p>
<p>（2）分析并将这些二进制数据流转换为方法区方法区特定的数据结构</p>
<p>（3）创建对应类的java.lang.Class对象，作为方法区的入口（有了对应的Class对象，并不意味着这个类已经完成了加载链接）</p>
<p>通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源：</p>
<p>（1）从本地文件系统加载class文件，这是绝大部分程序的加载方式</p>
<p>（2）从jar包中加载class文件，这种方式也很常见，例如jdbc编程时用到的数据库驱动类就是放在jar包中，<br>jvm可以从jar文件中直接加载该class文件</p>
<p>（3）通过网络加载class文件</p>
<p>（4）把一个Java源文件动态编译、并执行加载</p>
<h3 id="2、链接："><a href="#2、链接：" class="headerlink" title="2、链接："></a>2、链接：</h3><p>链接指的是将Java类的二进制文件合并到jvm的运行状态之中的过程。在链接之前，这个类必须被成功加载。</p>
<p>类的链接包括验证、准备、解析这三步。具体描述如下：</p>
<h4 id="2-1-验证："><a href="#2-1-验证：" class="headerlink" title="2.1  验证："></a>2.1  验证：</h4><p>验证是用来确保Java类的二进制表示在结构上是否完全正确（如文件格式、语法语义等）。如果验证过程出错的话，会抛出java.lang.VertifyError错误。</p>
<p>主要验证以下内容：<br>文件格式验证<br>元数据验证：语义验证<br>字节码验证</p>
<h4 id="2-2-准备："><a href="#2-2-准备：" class="headerlink" title="2.2  准备："></a>2.2  准备：</h4><p>准备过程则是创建Java类中的静态域（static修饰的内容），并将这些域的值设置为默认值，同时在方法区中分配内存空间。准备过程并不会执行代码。</p>
<p>注意这里是做默认初始化，不是做显式初始化。例如：<br>public static int value = 12;</p>
<p>上面的代码中，在准备阶段，会给value的值设置为0（默认初始化）。在后面的初始化阶段才会给value的值设置为12（显式初始化）。</p>
<h4 id="2-3-解析："><a href="#2-3-解析：" class="headerlink" title="2.3  解析："></a>2.3  解析：</h4><p>解析的过程就是确保这些被引用的类能被正确的找到（将符号引用替换为直接引用）。解析的过程可能会导致其它的Java类被加载。</p>
<h3 id="3、初始化："><a href="#3、初始化：" class="headerlink" title="3、初始化："></a>3、初始化：</h3><p>初始化阶段是类加载过程的最后一步。到了初始化阶段，才真正执行类中定义的Java程序代码<br>（或者说是字节码）。</p>
<p>在以下几种情况中，会执行初始化过程：</p>
<p>（1）创建类的实例</p>
<p>（2）访问类或接口的静态变量<br>（特例：如果是用static final修饰的常量，那就不会对类进行显式初始化。<br>static final 修改的变量则会做显式初始化）</p>
<p>（3）调用类的静态方法</p>
<p>（4）反射（Class.forName(packagename.className)）</p>
<p>（5）初始化类的子类。注：子类初始化问题：满足主动调用，即父类访问子类中的静态变量、方法，子类才会初始化；否则仅父类初始化。</p>
<p>（6）java虚拟机启动时被标明为启动类的类</p>
<h4 id="知识点：类的初始化过程（重要）"><a href="#知识点：类的初始化过程（重要）" class="headerlink" title="知识点：类的初始化过程（重要）"></a>知识点：类的初始化过程（重要）</h4><p>Student s = new Student();在内存中做了哪些事情?</p>
<p>加载Student.class文件进内存<br>在栈内存为s开辟空间<br>在堆内存为学生对象开辟空间<br>对学生对象的成员变量进行默认初始化<br>对学生对象的成员变量进行显示初始化<br>通过构造方法对学生对象的成员变量赋值<br>学生对象初始化完毕，把对象地址赋值给s变量</p>
<h2 id="九、解释运行和编译运行的概念："><a href="#九、解释运行和编译运行的概念：" class="headerlink" title="九、解释运行和编译运行的概念："></a>九、解释运行和编译运行的概念：</h2><h3 id="解释运行："><a href="#解释运行：" class="headerlink" title="解释运行："></a>解释运行：</h3><p>解释执行以解释方式运行字节码</p>
<p>解释执行的意思是：读一句执行一句</p>
<h3 id="编译运行（JIT）："><a href="#编译运行（JIT）：" class="headerlink" title="编译运行（JIT）："></a>编译运行（JIT）：</h3><p>将字节码编译成机器码</p>
<p>直接执行机器码</p>
<p>运行时编译</p>
<p>编译后性能有数量级的提升</p>
<p>编译运行的性能优于解释运行。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-java-GC" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/11/java-GC/" class="article-date">
  	<time datetime="2017-03-11T07:00:34.000Z" itemprop="datePublished">2017-03-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/11/java-GC/">java-GC</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一、为什么需要GC"><a href="#一、为什么需要GC" class="headerlink" title="一、为什么需要GC"></a>一、为什么需要GC</h3><h4 id="应用程序对资源操作，通常简单分为以下几个步骤："><a href="#应用程序对资源操作，通常简单分为以下几个步骤：" class="headerlink" title="应用程序对资源操作，通常简单分为以下几个步骤："></a>应用程序对资源操作，通常简单分为以下几个步骤：</h4><p>1、为对应的资源分配内存</p>
<p>2、初始化内存</p>
<p>3、使用资源</p>
<p>4、清理资源</p>
<p>5、释放内存</p>
<h4 id="应用程序对资源（内存使用）管理的方式，常见的一般有如下几种："><a href="#应用程序对资源（内存使用）管理的方式，常见的一般有如下几种：" class="headerlink" title="应用程序对资源（内存使用）管理的方式，常见的一般有如下几种："></a>应用程序对资源（内存使用）管理的方式，常见的一般有如下几种：</h4><p>1、手动管理：C,C++</p>
<p>2、计数管理：COM</p>
<p>3、自动管理：.NET,Java,PHP,GO…</p>
<h4 id="手动管理和计数管理的复杂性很容易产生以下典型问题："><a href="#手动管理和计数管理的复杂性很容易产生以下典型问题：" class="headerlink" title="手动管理和计数管理的复杂性很容易产生以下典型问题："></a>手动管理和计数管理的复杂性很容易产生以下典型问题：</h4><p>1.程序员忘记去释放内存</p>
<p>2.应用程序访问已经释放的内存</p>
<p>产生的后果很严重，常见的如内存泄露、数据内容乱码，而且大部分时候，程序的行为会变得怪异而不可预测，还有Access Violation等。</p>
<p>.NET、Java等给出的解决方案，就是通过自动垃圾回收机制GC进行内存管理。这样，问题1自然得到解决，问题2也没有存在的基础。</p>
<p>总结：无法自动化的内存管理方式极容易产生bug，影响系统稳定性，尤其是线上多服务器的集群环境，程序出现执行时bug必须定位到某台服务器然后dump内存再分析bug所在。</p>
<p>安全性考虑；– for security.<br>减少内存泄露；– erase memory leak in some degree.<br>减少程序员工作量。– Programmers don’t worry about memory releasing.</p>
<h3 id="二、GC如何工作"><a href="#二、GC如何工作" class="headerlink" title="二、GC如何工作"></a>二、GC如何工作</h3><h4 id="GC的工作流程主要分为如下几个步骤："><a href="#GC的工作流程主要分为如下几个步骤：" class="headerlink" title="GC的工作流程主要分为如下几个步骤："></a>GC的工作流程主要分为如下几个步骤：</h4><p>1、标记(Mark)</p>
<p>2、计划(Plan)</p>
<p>3、清理(Sweep)</p>
<p>4、引用更新(Relocate)</p>
<p>5、压缩(Compact)<br><img src="/img/gc.png" alt=""></p>
<h4 id="1-标记"><a href="#1-标记" class="headerlink" title="1.标记"></a>1.标记</h4><p>目标：找出所有引用不为0(live)的实例</p>
<p>方法：找到所有的GC的根结点(GC Root), 将他们放到队列里，然后依次递归地遍历所有的根结点以及引用<br>的所有子节点和子子节点，将所有被遍历到的结点标记成live。弱引用不会被考虑在内</p>
<h4 id="2-计划和清理"><a href="#2-计划和清理" class="headerlink" title="2.计划和清理"></a>2.计划和清理</h4><p>(1)计划</p>
<p>目标：判断是否需要压缩</p>
<p>方法：遍历当前所有的generation上所有的标记(Live),根据特定算法作出决策。</p>
<p>(2)清理</p>
<p>目标：回收所有的free空间</p>
<p>方法：遍历当前所有的generation上所有的标记(Live or Dead),把所有处在Live实例中间的内存块加入到可<br>用内存链表中去。</p>
<h4 id="3-引用更新和压缩"><a href="#3-引用更新和压缩" class="headerlink" title="3.引用更新和压缩"></a>3.引用更新和压缩</h4><p>（1）引用更新</p>
<p>目标： 将所有引用的地址进行更新</p>
<p>方法：计算出压缩后每个实例对应的新地址，找到所有的GC的根结点(GC Root), 将他们放到队列里，<br>然后依次递归地遍历所有的根结点以及引用的所有子节点和子子节点，将所有被遍历到的结点中引用的地址进行更新，包括弱引用。</p>
<p>（2）压缩</p>
<p>目标：减少内存碎片</p>
<p>方法：根据计算出来的新地址，把实例移动到相应的位置。</p>
<h3 id="三、GC的根节点"><a href="#三、GC的根节点" class="headerlink" title="三、GC的根节点"></a>三、GC的根节点</h3><p>每个应用程序都包含一组根（root），每个根都是一个存储位置，其中包含指向引用类型对象的一个指针。该指针要么引用托管堆中的一个对象，要么为null。</p>
<p>在应用程序中，只要某对象变得不可达，也就是没有根（root）引用该对象，这个对象就会成为垃圾回收器的目标。</p>
<p>用一句简洁的英文描述就是:GC roots are not objects in themselves but are instead references to objects.而且，Any object referenced by a GC root will automatically survive the next garbage collection. </p>
<p>注意，只有引用类型的变量才被认为是根，值类型的变量永远不被认为是根。只有深刻理解引用类型和值类型的内存分配和管理的不同，才能知道为什么root只能是引用类型。</p>
<p>在Java中，可以当做GC Root的对象有以下几种：</p>
<p>1、虚拟机（JVM）栈中的引用的对象</p>
<p>2、方法区中的类静态属性引用的对象</p>
<p>3、方法区中的常量引用的对象（主要指声明为final的常量值）</p>
<p>4、本地方法栈中JNI的引用的对象</p>
<h3 id="什么时候发生GC"><a href="#什么时候发生GC" class="headerlink" title="什么时候发生GC"></a>什么时候发生GC</h3><p>1、当应用程序分配新的对象，GC的代的预算大小已经达到阈值，比如GC的第0代已满</p>
<p>2、代码主动显式调用System.GC.Collect()</p>
<p>3、其他特殊情况，比如，windows报告内存不足、CLR卸载AppDomain、CLR关闭，甚至某些极端情况下系统参数设置改变也可能导致GC回收</p>
<h3 id="五、GC中的代"><a href="#五、GC中的代" class="headerlink" title="五、GC中的代"></a>五、GC中的代</h3><p>代（Generation)引入的原因主要是为了提高性能（Performance),以避免收集整个堆（Heap）。一个基于代的垃圾回收器做出了如下几点假设：</p>
<p>1、对象越新，生存期越短</p>
<p>2、对象越老，生存期越长</p>
<p>3、回收堆的一部分，速度快于回收整个堆</p>
<p>.NET的垃圾收集器将对象分为三代（Generation0,Generation1,Generation2）。不同的代里面的内容如下：</p>
<p>1、G0 小对象(Size&lt;85000Byte)</p>
<p>2、G1:在GC中幸存下来的G0对象</p>
<p>3、G2:大对象(Size&gt;=85000Byte);在GC中幸存下来的G1对象</p>
<p>ps，这里必须知道，CLR要求所有的资源都从托管堆（managed heap）分配，CLR会管理两种类型的堆，<br>小对象堆（small object heap，SOH）和大对象堆（large object heap，LOH），<br>其中所有大于85000byte的内存分配都会在LOH上进行。</p>
<p>一个有趣的问题是为什么是85000字节？</p>
<p>代收集规则：当一个代N被收集以后，在这个代里的幸存下来的对象会被标记为N+1代的对象。GC对不同代的对象执行不同的检查策略以优化性能。每个GC周期都会检查第0代对象。大约1/10的GC周期检查第0代和第1代对象。大约1/100的GC周期检查所有的对象。</p>
<h3 id="哪些内存需要回收"><a href="#哪些内存需要回收" class="headerlink" title="哪些内存需要回收"></a>哪些内存需要回收</h3><p>内存运行时JVM会有一个运行时数据区来管理内存。它主要包括5大部分：<br>程序计数器(Program Counter Register)、虚拟机栈(VM Stack)、本地方法栈(Native Method Stack)、方法区(Method Area)、堆(Heap).</p>
<p>而其中程序计数器、虚拟机栈、本地方法栈是每个线程私有的内存空间，随线程而生，随线程而亡。例如栈中每一个栈帧中分配多少内存基本上在类结构去诶是哪个下来时就已知了，因此这3个区域的内存分配和回收都是确定的，无需考虑内存回收的问题。</p>
<p>但方法区和堆就不同了，一个接口的多个实现类需要的内存可能不一样，我们只有在程序运行期间才会知道会创建哪些对象，这部分内存的分配和回收都是动态的，GC主要关注的是这部分内存。</p>
<h3 id="When-–-什么时候回收？"><a href="#When-–-什么时候回收？" class="headerlink" title="When? – 什么时候回收？"></a>When? – 什么时候回收？</h3><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>在面试中经常会碰到这样一个问题：如何判断一个对象已经死去？</p>
<p>很容易想到的一个答案是：对一个对象添加引用计数器。每当有地方引用它时，计数器值加1；当引用失效时，计数器值减1.而当计数器的值为0时这个对象就不会再被使用，判断为已死。是不是简单又直观。然而，很遗憾。这种做法是错误的！（面试时可千万别这样回答哦，我就是不假思索这样回答，然后就。。）为什么是错的呢？事实上，用引用计数法确实在大部分情况下是一个不错的解决方案，而在实际的应用中也有不少案例，但它却无法解决对象之间的循环引用问题。比如对象A中有一个字段指向了对象B，而对象B中也有一个字段指向了对象A，而事实上他们俩都不再使用，但计数器的值永远都不可能为0，也就不会被回收，然后就发生了内存泄露。。</p>
<p>所以，正确的做法应该是怎样呢？<br>在Java，C#等语言中，比较主流的判定一个对象已死的方法是：<br>可达性分析(Reachability Analysis).所有生成的对象都是一个称为”GC Roots”的根的子树。从GC Roots开始向下搜索，搜索所经过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链可以到达时，就称这个对象是不可达的（不可引用的），也就是可以被GC回收了。</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>当内存空间还够时，能够保存在内存中；如果进行了垃圾回收之后内存空间仍旧非常紧张，则可以抛弃这些对象。所以根据不同的需求，给出如下四种引用，根据引用类型的不同，GC回收时也会有不同的操作：</p>
<h4 id="强引用-Strong-Reference"><a href="#强引用-Strong-Reference" class="headerlink" title="强引用(Strong Reference):"></a>强引用(Strong Reference):</h4><p>Object obj = new Object();只要强引用还存在，GC永远不会回收掉被引用的对象。</p>
<h4 id="软引用-SoftReference-："><a href="#软引用-SoftReference-：" class="headerlink" title="软引用(SoftReference)："></a>软引用(SoftReference)：</h4><p>描述一些还有用但非必需的对象。在系统将会发生内存溢出之前，会把这些对象列入回收范围进行二次回收（即系统将会发生内存溢出了，才会对他们进行回收。）</p>
<h4 id="弱引用-Weak-Reference"><a href="#弱引用-Weak-Reference" class="headerlink" title="弱引用(Weak Reference):"></a>弱引用(Weak Reference):</h4><p>程度比软引用还要弱一些。这些对象只能生存到下次GC之前。当GC工作时，无论内存是否足够都会将其回收（即只要进行GC，就会对他们进行回收。）</p>
<h4 id="虚引用-Phantom-Reference"><a href="#虚引用-Phantom-Reference" class="headerlink" title="虚引用(Phantom Reference):"></a>虚引用(Phantom Reference):</h4><p>一个对象是否存在虚引用，完全不会对其生存时间构成影响。</p>
<h4 id="方法区：关于方法区中需要回收的是一些废弃的常量和无用的类。"><a href="#方法区：关于方法区中需要回收的是一些废弃的常量和无用的类。" class="headerlink" title="方法区：关于方法区中需要回收的是一些废弃的常量和无用的类。"></a>方法区：关于方法区中需要回收的是一些废弃的常量和无用的类。</h4><p>（1）废弃的常量的回收。这里看引用计数就可以了。没有对象引用该常量就可以放心的回收了。<br>（2）无用的类的回收。什么是无用的类呢？<br>     该类所有的实例都已经被回收。也就是Java堆中不存在该类的任何实例；<br>     加载该类的ClassLoader已经被回收；<br>     该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>对于堆中的对象，主要用可达性分析判断一个对象是否还存在引用，如果该对象没有任何引用就应该被回收。而根据我们实际对引用的不同需求，又分成了4中引用，每种引用的回收机制也是不同的。</p>
<p>对于方法区中的常量和类，当一个常量没有任何对象引用它，它就可以被回收了。而对于类，如果可以判定它为无用类，就可以被回收了。</p>
<h3 id="How-–-如何回收？"><a href="#How-–-如何回收？" class="headerlink" title="How? – 如何回收？"></a>How? – 如何回收？</h3><h4 id="标记-清除-Mark-Sweep-算法"><a href="#标记-清除-Mark-Sweep-算法" class="headerlink" title="标记-清除(Mark-Sweep)算法"></a>标记-清除(Mark-Sweep)算法</h4><p>分为两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。<br>缺点：效率问题，标记和清除两个过程的效率都不高；空间问题，会产生很多碎片。</p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>将可用内存按容量划分为大小相等的两块，每次只用其中一块。当这一块用完了，就将还存活的对象复制到另外一块上面，然后把原始空间全部回收。高效、简单。<br>缺点：将内存缩小为原来的一半。</p>
<h4 id="标记-整理-Mark-Compat-算法"><a href="#标记-整理-Mark-Compat-算法" class="headerlink" title="标记-整理(Mark-Compat)算法"></a>标记-整理(Mark-Compat)算法</h4><p>标记过程与标记-清除算法过程一样，但后面不是简单的清除，而是让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</p>
<h4 id="分代收集-Generational-Collection-算法"><a href="#分代收集-Generational-Collection-算法" class="headerlink" title="分代收集(Generational Collection)算法"></a>分代收集(Generational Collection)算法</h4><p>新生代中，每次垃圾收集时都有大批对象死去，只有少量存活，就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集；<br>老年代中，其存活率较高、没有额外空间对它进行分配担保，就应该使用“标记-整理”或“标记-清理”算法进行回收。</p>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>Java技术体系中所提倡的自动内存管理最终可以归结为自动化的解决2个问题：给对象分配内存以及回收分配给对象的内存。</p>
<h4 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h4><p>大多数情况下，对象在新生代Eden区分配。当Eden区没有足够的内存时，虚拟机将发起一次Minor GC。</p>
<p>Minor GC(新生代GC):指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC发生的非常频繁。</p>
<p>Full GC/Major GC(老年代GC):指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC。</p>
<h4 id="大对象直接进老年代"><a href="#大对象直接进老年代" class="headerlink" title="大对象直接进老年代"></a>大对象直接进老年代</h4><p>大对象是指需要大量连续内存空间的Java对象（例如很长的字符串以及数组）。</p>
<h4 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h4><p>JVM为每个对象定义一个对象年龄计数器。</p>
<p>如果对象在Eden出生并经历过第一次MinorGC后仍然存活，并且能够被Survivor容纳，则应该被移动到<br>Survivor空间中，并且年龄对象设置为1；</p>
<p>对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度(默认为15岁，<br>可通过参数-XX:MaxTenuringThreshold设置)，就会被晋升到老年代中。</p>
<p>要注意的是：JVM并不是永远的要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。</p>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，<br>如果这个条件成立，则进行Minor GC是安全的；</p>
<p>如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。<br>如果允许，则急促检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，<br>如果大于，将尝试着进行一次Minor GC，尽管它是有风险的；<br>如果小于或者HandePromotionFailure设置为不允许冒险，则这时要改为进行一次Full GC.</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-腾讯面经" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/10/腾讯面经/" class="article-date">
  	<time datetime="2017-03-10T11:22:32.000Z" itemprop="datePublished">2017-03-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/10/腾讯面经/">腾讯面经</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><p>面试部门：OMG(网络媒体事业群)<br>1.自我介绍<br>2.介绍项目<br>3.项目架构<br>4.项目中的难点  如何解决<br>5.算法题   两个链表存储两个多位数字，一个节点<br>存储一位，左边高位，右边低位，计算两数的和。<br>考点：链表遍历，逆序输出。<br>思路：<br>将链表中的数存储到栈中，高位在栈底，低位在栈顶，再从栈中取出来，分别计算出两个数的大小，再相加。</p>
<p>6.TCP三次握手<br>7.进程，线程，协程</p>
<p>进程：<br>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.</p>
<p>线程；<br>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.<br>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</p>
<p>区别：<br>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。 </p>
<p>1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.<br>2) 线程的划分尺度小于进程，使得多线程程序的并发性高。<br>3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。<br>4) 线程在执行过程中与进程还是有区别的。<br>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。<br>但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p>
<p>协程：<br>线程和进程的操作是由程序触发系统接口，最后的执行者是系统；协程的操作则是程序员。</p>
<p>协程存在的意义：对于多线程应用，CPU通过切片的方式来切换线程间的执行，线程切换时需要耗时<br>（保存状态，下次继续）。协程，则只使用一个线程，在一个线程中规定某个代码块执行顺序。</p>
<p>协程的适用场景：当程序中存在大量不需要CPU的操作时（IO），适用于协程；</p>
<p>8.内存管理<br>9.JVM</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-java-面试题-2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/09/java-面试题-2/" class="article-date">
  	<time datetime="2017-03-09T12:11:06.000Z" itemprop="datePublished">2017-03-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/09/java-面试题-2/">java-面试题-2</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-面向对象的特征有哪些方面？"><a href="#1-面向对象的特征有哪些方面？" class="headerlink" title="1.面向对象的特征有哪些方面？"></a>1.面向对象的特征有哪些方面？</h3><p>答：面向对象的特征主要有以下几个方面： </p>
<ul>
<li>抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 </li>
<li>继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。 </li>
<li>封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。 </li>
<li>多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：<br>1). 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；<br>2).对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</li>
</ul>
<h3 id="2-访问修饰符public-private-protected-以及不写（默认）时的区别？"><a href="#2-访问修饰符public-private-protected-以及不写（默认）时的区别？" class="headerlink" title="2.访问修饰符public,private,protected,以及不写（默认）时的区别？"></a>2.访问修饰符public,private,protected,以及不写（默认）时的区别？</h3><p>修饰符    当前类  同包   子类    其他包<br>public      √     √       √        √<br>protected   √     √       √        ×<br>default     √     √       ×        ×<br>private     √     ×       ×        ×<br>类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java中，外部类的修饰符只能是public或默认，类的成员（包括内部类）的修饰符可以是以上四种。</p>
<h3 id="3-String-是最基本的数据类型吗？"><a href="#3-String-是最基本的数据类型吗？" class="headerlink" title="3.String 是最基本的数据类型吗？"></a>3.String 是最基本的数据类型吗？</h3><p>答：不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（reference type），Java 5以后引入的枚举类型也算是一种比较特殊的引用类型。</p>
<h3 id="4-float-f-3-4-是否正确？"><a href="#4-float-f-3-4-是否正确？" class="headerlink" title="4.float f=3.4;是否正确？"></a>4.float f=3.4;是否正确？</h3><p>答:不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。</p>
<h3 id="5-short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？"><a href="#5-short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？" class="headerlink" title="5.short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？"></a>5.short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？</h3><p>答：对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。</p>
<h3 id="6-Java有没有goto？"><a href="#6-Java有没有goto？" class="headerlink" title="6.Java有没有goto？"></a>6.Java有没有goto？</h3><p>答：goto 是Java中的保留字，在目前版本的Java中没有使用。（根据James Gosling（Java之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字）</p>
<h3 id="6-int和Integer有什么区别？"><a href="#6-int和Integer有什么区别？" class="headerlink" title="6.int和Integer有什么区别？"></a>6.int和Integer有什么区别？</h3><p>答：Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。<br>Java 为每个原始类型提供了包装类型： </p>
<ul>
<li>原始类型: boolean，char，byte，short，int，long，float，double </li>
<li>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class AutoUnboxingTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer a = new Integer(3);</span><br><span class="line">        Integer b = 3;                  // 将3自动装箱成Integer类型</span><br><span class="line">        int c = 3;</span><br><span class="line">        System.out.println(a == b);     // <span class="literal">false</span> 两个引用没有引用同一对象</span><br><span class="line">        System.out.println(a == c);     // <span class="literal">true</span> a自动拆箱成int类型再和c比较</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test03 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150;</span><br><span class="line"></span><br><span class="line">        System.out.println(f1 == f2);</span><br><span class="line">        System.out.println(f3 == f4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不明就里很容易认为两个输出要么都是true要么都是false。首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象引用，所以下面的==运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，如果看看valueOf的源代码就知道发生了什么。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="built_in">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="built_in">return</span> new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简单的说，如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中f1==f2的结果是true，而f3==f4的结果是false。</p>
<h3 id="8-amp-和-amp-amp-的区别？"><a href="#8-amp-和-amp-amp-的区别？" class="headerlink" title="8.&amp;和&amp;&amp;的区别？"></a>8.&amp;和&amp;&amp;的区别？</h3><p>答：&amp;运算符有两种用法：(1)按位与；(2)逻辑与。<br>    &amp;&amp;运算符是短路与运算。<br>逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p>
<h3 id="9-解释内存中的栈-stack-、堆-heap-和方法区-method-area-的用法。"><a href="#9-解释内存中的栈-stack-、堆-heap-和方法区-method-area-的用法。" class="headerlink" title="9.解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。"></a>9.解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。</h3><p>答：通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用JVM中的栈空间；而通过new关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为Eden、Survivor（又可分为From Survivor和To Survivor）、Tenured；<br>方法区和堆都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息、常量、静态变量、JIT编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的100、”hello”和常量都是放在常量池中，常量池是方法区的一部分。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM的启动参数来进行调整，栈空间用光了会引发StackOverflowError，而堆和常量池空间不足则会引发OutOfMemoryError。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = new String(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面的语句中变量str放在栈上，用new创建出来的字符串对象放在堆上，而”hello”这个字面量是放在方法区的。</p>
<p>补充1：较新版本的Java（从Java 6的某个更新开始）中，由于JIT编译器的发展和”逃逸分析”技术的逐渐成熟，栈上分配、标量替换等优化技术使得对象一定分配在堆上这件事情已经变得不那么绝对了。</p>
<p>补充2：运行时常量池相当于Class文件常量池具有动态性，Java语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String类的intern()方法就是这样的。<br>看看下面代码的执行结果是什么并且比较一下Java 7以前和以后的运行结果是否一致。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new StringBuilder(<span class="string">"go"</span>)</span><br><span class="line">    .append(<span class="string">"od"</span>).toString();</span><br><span class="line">System.out.println(s1.intern() == s1);</span><br><span class="line">String s2 = new StringBuilder(<span class="string">"ja"</span>)</span><br><span class="line">    .append(<span class="string">"va"</span>).toString();</span><br><span class="line">System.out.println(s2.intern() == s2);</span><br></pre></td></tr></table></figure></p>
<h3 id="10-Math-round-11-5-等于多少？Math-round-11-5-等于多少？"><a href="#10-Math-round-11-5-等于多少？Math-round-11-5-等于多少？" class="headerlink" title="10.Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？"></a>10.Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？</h3><p>答：Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。</p>
<h3 id="11-switch-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上？"><a href="#11-switch-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上？" class="headerlink" title="11.switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？"></a>11.switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？</h3><p>答：在Java 5以前，switch(expr)中，expr只能是byte、short、char、int。从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型，从Java 7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</p>
<h3 id="12-用最有效率的方法计算2乘以8？"><a href="#12-用最有效率的方法计算2乘以8？" class="headerlink" title="12.用最有效率的方法计算2乘以8？"></a>12.用最有效率的方法计算2乘以8？</h3><p>答： 2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。</p>
<h3 id="13、数组有没有length-方法？String有没有length-方法？"><a href="#13、数组有没有length-方法？String有没有length-方法？" class="headerlink" title="13、数组有没有length()方法？String有没有length()方法？"></a>13、数组有没有length()方法？String有没有length()方法？</h3><p>答：数组没有length()方法，有length 的属性。String 有length()方法。</p>
<h3 id="14、在Java中，如何跳出当前的多重嵌套循环？"><a href="#14、在Java中，如何跳出当前的多重嵌套循环？" class="headerlink" title="14、在Java中，如何跳出当前的多重嵌套循环？"></a>14、在Java中，如何跳出当前的多重嵌套循环？</h3><p>答：在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环。（Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好）</p>
<h3 id="15-构造器（constructor）是否可被重写（override）？"><a href="#15-构造器（constructor）是否可被重写（override）？" class="headerlink" title="15.构造器（constructor）是否可被重写（override）？"></a>15.构造器（constructor）是否可被重写（override）？</h3><p>答：构造器不能被继承，因此不能被重写，但可以被重载；也就是说，能被继承的方法才能被重写。</p>
<h3 id="16-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><a href="#16-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？" class="headerlink" title="16.两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？"></a>16.两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？</h3><p>答：不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。<br>Java对于eqauls方法和hashCode方法是这样规定的：<br>(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；<br>(2)如果两个对象的hashCode相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。</p>
<p>首先equals方法必须满足自反性（x.equals(x)必须返回true）、对称性（x.equals(y)返回true时，y.equals(x)也必须返回true）、传递性（x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true）和一致性（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），而且对于任何非null值的引用x，x.equals(null)必须返回false。</p>
<h3 id="17-是否可以继承String类？"><a href="#17-是否可以继承String类？" class="headerlink" title="17.是否可以继承String类？"></a>17.是否可以继承String类？</h3><p>答：String 类是final类，不可以被继承。</p>
<h3 id="18-当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的"><a href="#18-当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的" class="headerlink" title="18.当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的"></a>18.当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的</h3><h3 id="结果，那么这里到底是值传递还是引用传递？"><a href="#结果，那么这里到底是值传递还是引用传递？" class="headerlink" title="结果，那么这里到底是值传递还是引用传递？"></a>结果，那么这里到底是值传递还是引用传递？</h3><p>答：是值传递。Java语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。</p>
<p>说明：Java中没有传引用实在是非常的不方便，这一点在Java 8中仍然没有得到改进，正是如此在Java编写的代码中才会出现大量的Wrapper类（将需要通过方法调用修改的引用置于一个Wrapper类中，再将Wrapper对象传入方法），这样的做法只会让代码变得臃肿，尤其是让从C和C++转型为Java程序员的开发者无法容忍。</p>
<h3 id="19-String和StringBuilder、StringBuffer的区别？"><a href="#19-String和StringBuilder、StringBuffer的区别？" class="headerlink" title="19.String和StringBuilder、StringBuffer的区别？"></a>19.String和StringBuilder、StringBuffer的区别？</h3><p>答：Java平台提供了两种类型的字符串：String和StringBuffer/StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。<br>而StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是Java 5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer要高。</p>
<p>面试题1 - 什么情况下用+运算符进行字符串连接比调用StringBuffer/StringBuilder对象的append方法连接字符串性能更好？</p>
<p>面试题2 - 请说出下面程序的输出。<br>class StringEqualTest {</p>
<pre><code>public static void main(String[] args) {
    String s1 = &quot;Programming&quot;;
    String s2 = new String(&quot;Programming&quot;);
    String s3 = &quot;Program&quot;;
    String s4 = &quot;ming&quot;;
    String s5 = &quot;Program&quot; + &quot;ming&quot;;
    String s6 = s3 + s4;
    System.out.println(s1 == s2);
    System.out.println(s1 == s5);
    System.out.println(s1 == s6);
    System.out.println(s1 == s6.intern());
    System.out.println(s2 == s2.intern());
}
</code></pre><p>}</p>
<p>补充：解答上面的面试题需要清除两点：<br>1.String对象的intern方法会得到字符串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与String对象的equals结果是true），如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用；2. 字符串的+操作其本质是创建了StringBuilder对象进行append操作，然后将拼接后的StringBuilder对象用toString方法处理成String对象，这一点可以用javap -c StringEqualTest.class命令获得class文件对应的JVM字节码指令就可以看出来。</p>
<h3 id="19-重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#19-重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="19.重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>19.重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h3><p>答：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。</p>
<h3 id="20-描述一下JVM加载class文件的原理机制？"><a href="#20-描述一下JVM加载class文件的原理机制？" class="headerlink" title="20.描述一下JVM加载class文件的原理机制？"></a>20.描述一下JVM加载class文件的原理机制？</h3><p>答：JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。<br>由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：<br>1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；<br>2)如果类中存在初始化语句，就依次执行这些初始化语句。<br>类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：</p>
<p>Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；<br>Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；<br>System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。</p>
<h3 id="21-char-型变量中能不能存贮一个中文汉字，为什么？"><a href="#21-char-型变量中能不能存贮一个中文汉字，为什么？" class="headerlink" title="21.char 型变量中能不能存贮一个中文汉字，为什么？"></a>21.char 型变量中能不能存贮一个中文汉字，为什么？</h3><p>答：char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char类型占2个字节（16比特），所以放一个中文是没问题的。<br>补充：使用Unicode意味着字符在JVM内部和外部有不同的表现形式，在JVM内部都是Unicode，当这个字符被从JVM内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以Java中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如InputStreamReader和OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于C程序员来说，要完成这样的编码转换恐怕要依赖于union（联合体/共用体）共享内存的特征来实现了。</p>
<h3 id="22-抽象类（abstract-class）和接口（interface）有什么异同？"><a href="#22-抽象类（abstract-class）和接口（interface）有什么异同？" class="headerlink" title="22.抽象类（abstract class）和接口（interface）有什么异同？"></a>22.抽象类（abstract class）和接口（interface）有什么异同？</h3><p>答：抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。</p>
<h3 id="23-静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？"><a href="#23-静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？" class="headerlink" title="23.静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？"></a>23.静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？</h3><p>答：Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。<br>而通常的内部类需要在外部类实例化后才能实例化。</p>
<h3 id="24-Java-中会存在内存泄漏吗，请简单描述。"><a href="#24-Java-中会存在内存泄漏吗，请简单描述。" class="headerlink" title="24.Java 中会存在内存泄漏吗，请简单描述。"></a>24.Java 中会存在内存泄漏吗，请简单描述。</h3><p>答：理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生。例如hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。 </p>
<h3 id="25-抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰？"><a href="#25-抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰？" class="headerlink" title="25.抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？"></a>25.抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？</h3><p>答：都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。</p>
<h3 id="26-阐述静态变量和实例变量的区别。"><a href="#26-阐述静态变量和实例变量的区别。" class="headerlink" title="26.阐述静态变量和实例变量的区别。"></a>26.阐述静态变量和实例变量的区别。</h3><p>答：静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。</p>
<h3 id="27-是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"><a href="#27-是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？" class="headerlink" title="27.是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"></a>27.是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</h3><p>答：不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。</p>
<h3 id="28-如何实现对象克隆？"><a href="#28-如何实现对象克隆？" class="headerlink" title="28.如何实现对象克隆？"></a>28.如何实现对象克隆？</h3><p>答：有两种方式：<br>（1）实现Cloneable接口并重写Object类中的clone()方法；<br>（2）实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。</p>
<h3 id="29-GC是什么？为什么要有GC？"><a href="#29-GC是什么？为什么要有GC？" class="headerlink" title="29.GC是什么？为什么要有GC？"></a>29.GC是什么？为什么要有GC？</h3><p>答：GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用。<br>垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。</p>
<p>补充：垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的Java进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java平台对堆内存回收和再利用的基本算法被称为标记和清除，但是Java对其进行了改进，采用“分代式垃圾收集”。这种方法会跟Java对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域： </p>
<ul>
<li>伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。 </li>
<li>幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。 </li>
<li>终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。</li>
</ul>
<h3 id="30-String-s-new-String-“xyz”-创建了几个字符串对象？"><a href="#30-String-s-new-String-“xyz”-创建了几个字符串对象？" class="headerlink" title="30.String s = new String(“xyz”);创建了几个字符串对象？"></a>30.String s = new String(“xyz”);创建了几个字符串对象？</h3><p>答：两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。</p>
<h3 id="32、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete-class）？"><a href="#32、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete-class）？" class="headerlink" title="32、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？"></a>32、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？</h3><p>答：接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。</p>
<h3 id="33、一个”-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"><a href="#33、一个”-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？" class="headerlink" title="33、一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"></a>33、一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？</h3><p>答：可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类<br>名完全保持一致。</p>
<h3 id="34、Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？"><a href="#34、Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？" class="headerlink" title="34、Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？"></a>34、Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？</h3><p>答：可以继承其他类或实现其他接口，在Swing编程和Android开发中常用此方式来实现事件监听和回调。</p>
<h3 id="35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"><a href="#35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？" class="headerlink" title="35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"></a>35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</h3><p>答：一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。</p>
<h3 id="36、Java-中的final关键字有哪些用法？"><a href="#36、Java-中的final关键字有哪些用法？" class="headerlink" title="36、Java 中的final关键字有哪些用法？"></a>36、Java 中的final关键字有哪些用法？</h3><p>答：(1)修饰类：表示该类不能被继承；(2)修饰方法：表示方法不能被重写；(3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。</p>
<h3 id="37、数据类型之间的转换："><a href="#37、数据类型之间的转换：" class="headerlink" title="37、数据类型之间的转换："></a>37、数据类型之间的转换：</h3><ul>
<li>如何将字符串转换为基本数据类型？ </li>
<li>如何将基本数据类型转换为字符串？<br>答： </li>
<li>调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型； </li>
<li>一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；另一种方法是调用String 类中的valueOf()方法返回相应字符串。</li>
</ul>
<h3 id="38、什么时候用断言"><a href="#38、什么时候用断言" class="headerlink" title="38、什么时候用断言"></a>38、什么时候用断言</h3><p>断言在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式的值为false，那么系统会报告一个AssertionError。断言的使用如下面的代码所示：</p>
<h3 id="39、Error和Exception有什么区别？"><a href="#39、Error和Exception有什么区别？" class="headerlink" title="39、Error和Exception有什么区别？"></a>39、Error和Exception有什么区别？</h3><p>答：Error表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。</p>
<h3 id="40、try-里有一个return语句，那么紧跟在这个try后的finally-里的代码会不会被执行，什么时候被执行，在return前还是后"><a href="#40、try-里有一个return语句，那么紧跟在这个try后的finally-里的代码会不会被执行，什么时候被执行，在return前还是后" class="headerlink" title="40、try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后?"></a>40、try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后?</h3><p>答：会执行，在方法返回调用者前执行。</p>
<h3 id="41、Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？"><a href="#41、Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？" class="headerlink" title="41、Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？"></a>41、Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？</h3><p>答：Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；try用来指定一块预防所有异常的程序；catch子句紧跟在try块后面，用来指定你想要捕获的异常的类型；throw语句用来明确地抛出一个异常；throws用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；finally为确保一段代码不管发生什么异常状况都要被执行；try语句可以嵌套，每当遇到一个try语句，异常的结构就会被放入异常栈中，直到所有的try语句都完成。如果下一级的try语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的try语句或者最终将异常抛给JVM。</p>
<h3 id="42、阐述final、finally、finalize的区别。"><a href="#42、阐述final、finally、finalize的区别。" class="headerlink" title="42、阐述final、finally、finalize的区别。"></a>42、阐述final、finally、finalize的区别。</h3><p>答：<br>final：修饰符（关键字）有三种用法：如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。将变量声明为final，可以保证它们在使用中不被改变，被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为final的方法也同样只能使用，不能在子类中被重写。 </p>
<p>finally：通常放在try…catch…的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。 </p>
<p>finalize：Object类中定义的方法，Java中允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或者执行其他清理工作。</p>
<h3 id="43、List、Set、Map是否继承自Collection接口？"><a href="#43、List、Set、Map是否继承自Collection接口？" class="headerlink" title="43、List、Set、Map是否继承自Collection接口？"></a>43、List、Set、Map是否继承自Collection接口？</h3><p>答：List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。</p>
<h3 id="44、阐述ArrayList、Vector、LinkedList的存储性能和特性。"><a href="#44、阐述ArrayList、Vector、LinkedList的存储性能和特性。" class="headerlink" title="44、阐述ArrayList、Vector、LinkedList的存储性能和特性。"></a>44、阐述ArrayList、Vector、LinkedList的存储性能和特性。</h3><p>答：<br>ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，<br>它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。</p>
<p>补充：遗留容器中的Properties类和Stack类在设计上有严重的问题，Properties是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个Hashtable并将其两个泛型参数设置为String类型，但是Java API中的Properties直接继承了Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是Has-A关系而不是Is-A关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是Has-A关系（关联）或Use-A关系（依赖）。同理，Stack类继承Vector也是不正确的。Sun公司的工程师们也会犯这种低级错误，让人唏嘘不已。</p>
<h3 id="45、Collection和Collections的区别？"><a href="#45、Collection和Collections的区别？" class="headerlink" title="45、Collection和Collections的区别？"></a>45、Collection和Collections的区别？</h3><p>答：Collection是一个接口，它是Set、List等容器的父接口；Collections是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。</p>
<h3 id="46、List、Map、Set三个接口存取元素时，各有什么特点？"><a href="#46、List、Map、Set三个接口存取元素时，各有什么特点？" class="headerlink" title="46、List、Map、Set三个接口存取元素时，各有什么特点？"></a>46、List、Map、Set三个接口存取元素时，各有什么特点？</h3><p>答：List以特定索引来存取元素，可以有重复元素。Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。<br>Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希存储<br>和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。</p>
<h3 id="47、线程的sleep-方法和yield-方法有什么区别？"><a href="#47、线程的sleep-方法和yield-方法有什么区别？" class="headerlink" title="47、线程的sleep()方法和yield()方法有什么区别？"></a>47、线程的sleep()方法和yield()方法有什么区别？</h3><p>（1）sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；<br>（2）线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；<br>（3）sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；<br>（4）sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。</p>
<h3 id="48、什么是线程池（thread-pool）？"><a href="#48、什么是线程池（thread-pool）？" class="headerlink" title="48、什么是线程池（thread pool）？"></a>48、什么是线程池（thread pool）？</h3><p>答：在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。 </p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-java-面试题-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/09/java-面试题-1/" class="article-date">
  	<time datetime="2017-03-09T11:55:03.000Z" itemprop="datePublished">2017-03-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/09/java-面试题-1/">java-面试题-1</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="java必须知道的300个问题-读书总结"><a href="#java必须知道的300个问题-读书总结" class="headerlink" title="java必须知道的300个问题  读书总结"></a>java必须知道的300个问题  读书总结</h2><p>1.表达式3-2.6==0.4的值？</p>
<p>答：false。 这是有基本数据类型浮点数计算的不精确性造成的。</p>
<p>3-2.6=0.39999999999999999999..</p>
<p>可以用BigDecimal进行浮点数精确计算。</p>
<p>2.&amp;和&amp;&amp;两个运算符的区别？</p>
<p>答：&amp; 位与，&amp;&amp; 逻辑与。</p>
<p>3.不适用循环和条件语句如何求1+2+3+…+n？</p>
<p>答：函数递归调用。</p>
<p>4.能正确编译”short s=1;s=s+1;”吗？</p>
<p>答：不能。类型不匹配。可：s+=1；</p>
<ol>
<li>+= 计算结果一定正确吗？</li>
</ol>
<p>答：不。可能溢出。</p>
<p>6.两个整数相乘结果一定正确吗？</p>
<p>不。</p>
<p>long num=2147483648.超出int范围，编译错误。</p>
<p>long num=214748364*10 结果为-10.int溢出。</p>
<p>long num=2147483648L*10 正确。</p>
<p>7.如何跳出多重嵌套循环？</p>
<p>label:<br>fori(){<br>break label;<br>}<br>8.存储相同数据量的一维数组和二维数组所占内存是否相同？</p>
<p>二维数组远远大于一维数组。</p>
<p>9.只能通过构造方法构造对象吗？</p>
<p>不是。</p>
<p>Calendar c=Clalendar.getInstance();</p>
<p>10.接口和抽象类的区别？</p>
<p>（1）抽象类可以提供成员的实现细节，而接口不能。数级抽象时如果要求提供成员的实现细节，可选抽象类。</p>
<p>（2）如果涉及抽象时选择抽象类，在以后的版本中可以随意为抽象类添加新成员。而接口只有修改现有代码才能添加新成员。</p>
<p>（3）一个类可以实现多个接口，但是能继承一个抽象类。如果要实现类似多重继承的效果，选接口。</p>
<p>两者相似，某些功能可以互换。但理念不同，抽象类用于继承，表示is-a；接口用于实现，表示like-a。</p>
<p>11.clone()方法的使用？</p>
<p>1.浅克隆</p>
<p>被克隆的对象各个属性都是基本类型，而不是引用类型，如果存在引用类型的属性，则需要进行深克隆。</p>
<p>2.深克隆</p>
<p>如果需要克隆的对象的域包含引用类型，则需要使用深克隆；<br>繁殖，可以直接使用Object类的clone()方法进行浅克隆。</p>
<p>12.两种方式可以实现深克隆，效率如何？</p>
<p>1.序列化，效率很差。</p>
<p>2.榆次克隆各个可变的引用类型域的方式。</p>
<p>13.在内部类中调用外部类同名的成员？</p>
<p>在内部类中调用内容类的x： this.x=…</p>
<p>在内部类调用外部类的X: TheSamName.this.x=…</p>
<p>15.自动装包、拆包？</p>
<p>基本数据类型自动转换成类.集合中不能存储基本数据类型。</p>
<p>int a=3;</p>
<p>arraylist.add(a);</p>
<p>16.String可以被继承么？</p>
<p>不可以。final修饰的类不能被继承。</p>
<p>17.各种进制的转换</p>
<p>Integer.parseInt(“101001010”,2);二进制转int<br>Integer.toBinaryString(int i);<br>…</p>
<p>Java集合类框架</p>
<p>18.数组 和 集合的转换</p>
<p>List list=new Arrays.asList(1,2,3,4,5);</p>
<p>Interger[] array=list.toArray(new Integer[]{});</p>
<p>19.Collection 和 Collections 的区别？</p>
<p>Collection是集合类的派生接口。是Java集合类的基础。</p>
<p>Collections是为集合类定义的工具类，包含了一些查找排序的方法，非常实用。</p>
<p>20.获得Map中的全部键？</p>
<p>Map接口中的keySet()方法</p>
<p>Set keySet()</p>
<p>Set keySet=map.keySet();</p>
<p>然后通过键获得值。</p>
<p>21.获得Map中的全部值？</p>
<p>values()</p>
<p>Collection values()</p>
<p>Collection values=map.values();</p>
<p>22.获得Map中的全部键值对？</p>
<p>Set</p>
<p>异常处理</p>
<p>23.throw和throws区别</p>
<p>throws是方法里的声明要抛出什么异常</p>
<p>throw是抛出具体异常</p>
<p>I/O</p>
<p>24.对象流？</p>
<p>DataInput DataOutput 可以吧对象写入到磁盘中</p>
<p>但是读写的对象必须实现了Serializable接口。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 明动天下
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>